Created output directory: output_gpu_charge1

Parallel computation enabled: 12 threads (auto-detected)

======================================================================
MOLECULE SETUP
======================================================================
Loading molecule from: PTCDA_clean.xyz
Basis set: 6-31g
Charge: 1
#INFO: **** input file is /home/indranil/Documents/Secondment/test/PTCDA/anion_cal/tdm_calc_accurate_GPU.py ****
#!/usr/bin/env python
'''
GPU-Accelerated Transition Density Matrix Calculation
Based on official PySCF examples with GPU4PySCF support

Features:
- GPU acceleration for DFT and TDDFT (B3LYP, UKS fully supported)
- Parallel calculation support
- Configurable grid size and box dimensions
- Selective state output
- HOMO/LUMO cube file generation

Requirements:
- pip install gpu4pyscf-cuda12x
- pip install cutensor-cu12 (optional, for 10-20% better performance)
'''

from pyscf import gto, lib
from pyscf.tools import cubegen, molden
from gpu4pyscf import dft
from gpu4pyscf.tdscf import rks as gpu_tdrks, uks as gpu_tduks
import numpy as np
from functools import reduce
import os

# ============================================================================
# CONFIGURATION SECTION - MODIFY THESE SETTINGS
# ============================================================================

# --- Parallel Calculation Settings ---
# Note: GPU handles DFT/TDDFT parallelization automatically
ENABLE_PARALLEL = True  # Enable/disable parallel computation for CPU operations
NUM_THREADS = 0

# --- Molecule Selection ---
USE_XYZ = True
# XYZ_FILE = 'H2O.xyz'  # Path to XYZ file
XYZ_FILE = 'PTCDA_clean.xyz'
BASIS_SET = '6-31g'

# --- Charge and Spin Settings ---
CHARGE = 1
SPIN = None
# Note: Spin is auto-calculated from electron count if set to None
# For charged systems: cation (+1) typically has spin=2 (doublet), anion (-1) has spin=2 (doublet)
# Neutral even-electron systems typically have spin=1 (singlet)

# --- DFT/TDDFT Settings ---
# Note: TDDFT uses the same basis set and XC functional as ground state DFT
XC_FUNCTIONAL = 'b3lyp'
# Common options:
#   'b3lyp'    - B3LYP (hybrid, good general purpose)
#   'pbe0'     - PBE0 (hybrid, good for excited states)
#   'cam-b3lyp' - CAM-B3LYP (range-separated, good for charge transfer)
#   'wb97x-d'  - ωB97X-D (range-separated with dispersion)
#   'pbe'      - PBE (GGA, faster but less accurate)
#   'blyp'     - BLYP (GGA)

NUM_EXCITED_STATES = 10

# --- TDDFT Method Selection ---
USE_TDA = False
# TDA (Tamm-Dancoff Approximation) is recommended for large systems or initial testing
# For charged/open-shell systems, TDDFT automatically uses appropriate method
# Closed-shell (spin=1): Uses RKS/TDDFT or RKS/TDA
# Open-shell (spin>1): Uses UKS/TDDFT or UKS/TDA

# --- Output Selection ---
# STATES_TO_OUTPUT: Which states to generate CUBE FILES for (0-indexed)
# Cube files are large (~150-500 MB per state), so be selective
# Examples:
#   [0, 1, 2] - First three states
#   [0, 4, 9] - States 1, 5, and 10
#   range(5) - First five states
STATES_TO_OUTPUT = [0, 1, 2]

# --- Cube File Generation Options ---
GENERATE_TRANSITION_DENSITY = True
GENERATE_EXCITED_DENSITY = True
GENERATE_DENSITY_DIFFERENCE = True
GENERATE_HOMO_LUMO = True

# --- Grid Settings ---
# Option 1: Use grid resolution (number of points per axis)
USE_GRID_RESOLUTION = False
GRID_RESOLUTION = [80, 80, 80]

# Option 2: Use box dimensions (in Angstrom) - only used if USE_GRID_RESOLUTION = False
BOX_MARGIN = 4.0
GRID_SPACING = 0.2

# --- NTO Analysis ---
# NTO_STATES: Which states to perform NTO ANALYSIS for (0-indexed)
# NTO molden files are small (~5 MB per state), so you can analyze more states
# This is INDEPENDENT of STATES_TO_OUTPUT - you can have different lists
# Example: Generate cube files for [0,1] but NTO analysis for [0,1,2,3,4]
ENABLE_NTO_ANALYSIS = True
NTO_STATES = [0, 1, 2]

# --- Transition Contribution Analysis ---
# Analyze which orbital pairs (i→a) contribute to each excited state
# Shows percentage contribution and generates cube files for dominant pairs
ENABLE_CONTRIBUTION_ANALYSIS = True
CONTRIBUTION_STATES = [0, 1, 2]
CONTRIBUTION_THRESHOLD = 0.01
TOP_N_CONTRIBUTIONS = 10
GENERATE_PAIR_CUBES = True
MAX_PAIRS_PER_STATE = 3
PAIR_CONTRIBUTION_CUTOFF = 0.05

# --- Output Directory ---
OUTPUT_DIR = 'output_gpu_charge1'

# ============================================================================
# END OF CONFIGURATION
# ============================================================================

# ============================================================================
# SETUP AND INITIALIZATION
# ============================================================================

# Create output directory
if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)
    print(f"Created output directory: {OUTPUT_DIR}")

# Setup parallel computation
if ENABLE_PARALLEL:
    if NUM_THREADS > 0:
        lib.num_threads(NUM_THREADS)
        print(f"\nParallel computation enabled: {NUM_THREADS} threads")
    else:
        # Auto-detect number of cores
        import multiprocessing
        num_cores = multiprocessing.cpu_count()
        lib.num_threads(num_cores)
        print(f"\nParallel computation enabled: {num_cores} threads (auto-detected)")
else:
    lib.num_threads(1)
    print("\nParallel computation disabled: using 1 thread")

# ============================================================================
# 1. MOLECULE DEFINITION
# ============================================================================

def create_h2o_molecule():
    """Create H2O test molecule"""
    mol = gto.M(
        atom = '''
        O  0.0000  0.0000  0.1173
        H  0.0000  0.7572 -0.4692
        H  0.0000 -0.7572 -0.4692
        ''',
        basis = BASIS_SET,
        verbose = 4
    )
    return mol

def calculate_spin_multiplicity(n_electrons, charge):
    """
    Calculate spin multiplicity (2S+1) from electron count.
    
    Args:
        n_electrons: Total number of electrons in neutral molecule
        charge: Molecular charge
    
    Returns:
        spin: Spin multiplicity (2S+1)
    """
    # Adjust electron count for charge
    n_elec = n_electrons - charge
    
    # For even number of electrons: singlet (spin=1)
    # For odd number of electrons: doublet (spin=2)
    if n_elec % 2 == 0:
        spin = 1  # Singlet (closed-shell)
    else:
        spin = 2  # Doublet (open-shell)
    
    return spin

def create_molecule_from_xyz(xyz_file, basis, charge=0, spin=None):
    """
    Load molecule from XYZ file with charge and spin.
    
    Args:
        xyz_file: Path to XYZ file
        basis: Basis set
        charge: Molecular charge
        spin: Spin multiplicity (None = auto-calculate)
    """
    # First, create molecule to get electron count
    mol_temp = gto.M(atom=xyz_file, basis=basis, charge=0, spin=0, verbose=0)
    n_electrons = mol_temp.nelectron
    
    # Calculate spin if not provided
    if spin is None:
        spin = calculate_spin_multiplicity(n_electrons, charge)
    
    # Create final molecule with charge and spin
    mol = gto.M(
        atom = xyz_file,
        basis = basis,
        charge = charge,
        spin = spin - 1,  # PySCF uses 2S (number of unpaired electrons), not 2S+1
        verbose = 4
    )
    
    return mol, spin

print("\n" + "="*70)
print("MOLECULE SETUP")
print("="*70)

if USE_XYZ:
    print(f"Loading molecule from: {XYZ_FILE}")
    print(f"Basis set: {BASIS_SET}")
    print(f"Charge: {CHARGE}")
    mol, calculated_spin = create_molecule_from_xyz(XYZ_FILE, BASIS_SET, CHARGE, SPIN)
    actual_spin = calculated_spin
else:
    print("Using H2O test molecule")
    print(f"Basis set: {BASIS_SET}")
    mol = create_h2o_molecule()
    actual_spin = 1  # H2O is singlet

print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity (2S+1): {actual_spin}")
print(f"Number of unpaired electrons (2S): {mol.spin}")

if actual_spin == 1:
    print("System type: Closed-shell (singlet)")
    dft_method = "RKS"
else:
    print(f"System type: Open-shell ({['singlet', 'doublet', 'triplet', 'quartet', 'quintet'][actual_spin-1] if actual_spin <= 5 else f'spin={actual_spin}'})")
    dft_method = "UKS"

print(f"DFT method: {dft_method} (GPU-accelerated)")

# ============================================================================
# 2. GROUND STATE DFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("GROUND STATE DFT CALCULATION")
print("="*70)
print(f"XC functional: {XC_FUNCTIONAL}")
print(f"Basis set: {BASIS_SET}")
print(f"Method: {dft_method} (GPU-accelerated)")

# Select RKS (closed-shell) or UKS (open-shell) based on spin
if actual_spin == 1:
    mf = dft.RKS(mol)
else:
    mf = dft.UKS(mol)

mf.xc = XC_FUNCTIONAL
mf.kernel()

if not mf.converged:
    print("WARNING: SCF did not converge!")
    print("Try: 1) Different initial guess, 2) Level shifting, 3) DIIS settings")
else:
    print("✓ SCF converged")

print(f"Ground state energy: {mf.e_tot:.6f} a.u.")

# ============================================================================
# 3. TDDFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("TDDFT CALCULATION")
print("="*70)
print(f"Note: TDDFT inherits XC functional ({XC_FUNCTIONAL}) and basis set ({BASIS_SET}) from ground state")
method_name = 'TDA' if USE_TDA else 'TDDFT'
spin_type = 'RKS' if actual_spin == 1 else 'UKS'
print(f"TDDFT method: {method_name} ({spin_type}-based, GPU-accelerated)")

# Select TDA or full TDDFT
# Use gpu4pyscf.tdscf module (RKS or UKS based on spin)
if actual_spin == 1:
    # Closed-shell: use gpu4pyscf.tdscf.rks
    if USE_TDA:
        td = gpu_tdrks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tdrks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
else:
    # Open-shell: use gpu4pyscf.tdscf.uks
    if USE_TDA:
        td = gpu_tduks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tduks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
td.nstates = NUM_EXCITED_STATES
print(f"Calculating {NUM_EXCITED_STATES} excited states...")
td.kernel()

# Handle both RKS (scalar) and UKS (array) convergence
if hasattr(td.converged, '__len__'):  # UKS: array
    if not td.converged.all():
        print(f"WARNING: TDDFT did not converge for some states!")
        print(f"  Converged states: {td.converged.sum()}/{len(td.converged)}")
    else:
        print("✓ TDDFT converged (all states)")
else:  # RKS: scalar
    if not td.converged:
        print("WARNING: TDDFT did not converge!")
    else:
        print("✓ TDDFT converged")

td.analyze()  # Print detailed analysis

# Print excitation energies
print("\n" + "="*70)
print("EXCITED STATE ENERGIES")
print("="*70)
for i, energy in enumerate(td.e):
    print(f"State {i+1}: {energy:.6f} a.u. = {energy*27.211:.3f} eV")
print("="*70)

# ============================================================================
# 4. TRANSITION DIPOLE MOMENTS
# ============================================================================

print("\n" + "="*70)
print("TRANSITION DIPOLE MOMENTS")
print("="*70)

# Set gauge origin to nuclear charge center
charges = mol.atom_charges()
coords = mol.atom_coords()  # in a.u.
nuc_charge_center = np.einsum('z,zx->x', charges, coords) / charges.sum()
mol.set_common_orig_(nuc_charge_center)

# Calculate dipole integrals
dip_ints = mol.intor('cint1e_r_sph', comp=3)  # x, y, z components

def calculate_transition_dipole(td, state_id):
    """
    Calculate transition dipole moment for a given excited state.
    Based on PySCF example: examples/1-advanced/030-transition_dipole.py
    
    Handles both RKS (closed-shell) and UKS (open-shell) cases.
    For GPU4PySCF, converts CuPy arrays to NumPy arrays.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    tdm : ndarray, shape (3,)
        Transition dipole moment [x, y, z] in a.u.
    """
    # Get TDDFT amplitudes (X and Y vectors)
    X, Y = td.xy[state_id]
    
    # Get MO coefficients and occupations
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    
    # Check if UKS by checking if X is a tuple (more reliable than mo_coeff)
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS: mo_coeff and mo_occ are tuples (alpha, beta)
        # For UKS, X and Y are also tuples: ((Xa, Xb), (Ya, Yb))
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        # Xa and Xb are already separated, just need to get dimensions
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Transition density matrices for alpha and beta
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        # Total transition density (alpha + beta)
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
        
    else:
        # RKS: mo_coeff and mo_occ are arrays
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        # Transition density in MO basis
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        
        # Transform to AO basis
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    # Calculate transition dipole: μ = Tr(μ_op * T)
    tdm = np.einsum('xij,ji->x', dip_ints, t_dm1_ao)
    
    return tdm

# Calculate and print transition dipoles for all states
print("\nTransition dipole moments (a.u.):")
print(f"{'State':<8} {'μ_x':<12} {'μ_y':<12} {'μ_z':<12} {'|μ|':<12} {'f':<12}")
print("-" * 70)

for i in range(td.nstates):
    tdm = calculate_transition_dipole(td, i)
    tdm_magnitude = np.linalg.norm(tdm)
    
    # Oscillator strength: f = (2/3) * ω * |μ|^2
    # where ω is excitation energy in a.u.
    omega = td.e[i]
    osc_strength = (2.0/3.0) * omega * tdm_magnitude**2
    
    print(f"{i+1:<8} {tdm[0]:>11.6f} {tdm[1]:>11.6f} {tdm[2]:>11.6f} "
          f"{tdm_magnitude:>11.6f} {osc_strength:>11.6f}")

print("="*70)

# ============================================================================
# 5. TRANSITION DENSITY MATRICES
# ============================================================================

def calculate_transition_density_matrix(td, state_id):
    """
    Calculate transition density matrix between ground and excited state.
    This is the proper transition density for visualization.
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    t_dm1_ao : ndarray
        Transition density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Alpha
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_mo_a[nocc_a:, :nocc_a] = (Xa + Ya).T
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        # Beta
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_mo_b[nocc_b:, :nocc_b] = (Xb + Yb).T
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
    else:
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        t_dm1_mo[nocc:, :nocc] = (X + Y).reshape(nocc, nvir).T
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    return t_dm1_ao

def calculate_excited_state_density(td, state_id):
    """
    Calculate excited state density matrix.
    Based on PySCF examples/tddft/22-density.py
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    dm_excited : ndarray
        Excited state density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mf = td._scf
    mo_coeff = mf.mo_coeff
    mo_occ = mf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS case - simplified approach: use transition density
        # For visualization, transition density is more meaningful
        return calculate_transition_density_matrix(td, state_id)
    else:
        # RKS case
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        nocc = X.shape[0]
        
        # Density matrix changes in MO basis
        dm_oo = -np.einsum('ia,ka->ik', X.conj(), X)
        dm_oo -= np.einsum('ia,ka->ik', Y.conj(), Y)
        
        dm_vv = np.einsum('ia,ic->ac', X, X.conj())
        dm_vv += np.einsum('ia,ic->ac', Y, Y.conj())
        
        # Start with ground state density in MO basis
        dm = np.diag(mo_occ)
        
        # Add TDDFT contribution
        dm[:nocc, :nocc] += dm_oo * 2
        dm[nocc:, nocc:] += dm_vv * 2
        
        # Transform to AO basis
        dm_excited = np.einsum('pi,ij,qj->pq', mo_coeff, dm, mo_coeff.conj())
    
    return dm_excited

# ============================================================================
# 5A. TRANSITION CONTRIBUTION ANALYSIS FUNCTIONS
# ============================================================================

def get_orbital_labels(mf):
    """Get orbital labels (HOMO-n, LUMO+n) for RKS and UKS."""
    mo_occ = mf.mo_occ
    
    # Handle UKS (use alpha spin) and CuPy arrays
    if isinstance(mo_occ, tuple):
        mo_occ = mo_occ[0]
    if hasattr(mo_occ, 'get'):
        mo_occ = mo_occ.get()
    
    homo_idx = np.where(mo_occ > 0)[0][-1]
    
    labels = []
    for i in range(len(mo_occ)):
        if i <= homo_idx:
            offset = homo_idx - i
            labels.append('HOMO' if offset == 0 else f'HOMO-{offset}')
        else:
            offset = i - homo_idx - 1
            labels.append('LUMO' if offset == 0 else f'LUMO+{offset}')
    
    return labels, homo_idx

def analyze_transition_contributions(td, state_id, mf, threshold=0.01, top_n=10):
    """
    Analyze orbital pair contributions to a specific excited state.
    Handles both RKS and UKS systems, and CuPy arrays.
    
    Returns:
        contributions: list of (occ_idx, vir_idx, weight, label) sorted by weight
        total_weight: sum of all weights
    """
    X, Y = td.xy[state_id]
    
    # Handle UKS: X and Y are tuples (Xa, Xb), (Ya, Yb)
    # For simplicity, analyze alpha spin (dominant for most cases)
    if isinstance(X, tuple):
        X, _ = X
        Y, _ = Y
    
    # Convert CuPy to NumPy if needed
    if hasattr(X, 'get'):
        X = X.get()
    if hasattr(Y, 'get'):
        Y = Y.get()
    
    nocc, nvir = X.shape
    
    # For full TDDFT, the contribution is from (X + Y)
    amplitudes = X + Y
    
    # Calculate weights (squared amplitudes)
    weights = amplitudes ** 2
    
    # Get orbital labels
    labels, homo_idx = get_orbital_labels(mf)
    
    # Collect all contributions
    contributions = []
    for i in range(nocc):
        for a in range(nvir):
            weight = weights[i, a]
            if weight > threshold:
                occ_idx = i
                vir_idx = nocc + a
                occ_label = labels[occ_idx]
                vir_label = labels[vir_idx]
                transition_label = f"{occ_label} → {vir_label}"
                contributions.append((occ_idx, vir_idx, weight, transition_label))
    
    # Sort by weight (descending)
    contributions.sort(key=lambda x: x[2], reverse=True)
    
    # Normalize weights to sum to 1
    total_weight = sum(c[2] for c in contributions)
    if total_weight > 0:
        contributions = [(occ, vir, w/total_weight, label) 
                         for occ, vir, w, label in contributions]
    
    # Return top N
    return contributions[:top_n], total_weight

def calculate_pair_transition_density(mf, occ_idx, vir_idx):
    """
    Calculate transition density matrix for a single orbital pair i→a.
    Handles both RKS and UKS (uses alpha spin for UKS), and CuPy arrays.
    
    T_μν = C_μ^i × C_ν^a + C_μ^a × C_ν^i
    """
    mo_coeff = mf.mo_coeff
    
    # Handle UKS (use alpha spin)
    if isinstance(mo_coeff, tuple):
        mo_coeff = mo_coeff[0]
    
    # Convert CuPy to NumPy if needed
    if hasattr(mo_coeff, 'get'):
        mo_coeff = mo_coeff.get()
    
    occ_mo = mo_coeff[:, occ_idx]
    vir_mo = mo_coeff[:, vir_idx]
    
    # Transition density matrix for this pair
    t_dm = np.outer(occ_mo, vir_mo) + np.outer(vir_mo, occ_mo)
    
    return t_dm

# ============================================================================
# 6. NATURAL TRANSITION ORBITALS (NTO) ANALYSIS
# ============================================================================

if ENABLE_NTO_ANALYSIS:
    print("\n" + "="*70)
    print("NATURAL TRANSITION ORBITAL ANALYSIS")
    print("="*70)
    
    # Filter valid NTO states
    valid_nto_states = [s for s in NTO_STATES if s < td.nstates]
    
    if not valid_nto_states:
        print("No valid NTO states selected.")
    else:
        for i in valid_nto_states:
            print(f"\nState {i+1} ({td.e[i]*27.211:.3f} eV):")
            weights, nto_coeff = td.get_nto(state=i+1, verbose=4)
            
            # Save NTO orbitals to molden format for visualization
            # For UKS, nto_coeff is a tuple (alpha, beta)
            if isinstance(nto_coeff, tuple):
                # Save alpha NTOs
                molden_file_a = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_alpha.molden')
                molden.from_mo(mol, molden_file_a, nto_coeff[0])
                print(f"  Alpha NTO orbitals saved to: {molden_file_a}")
                
                # Save beta NTOs
                molden_file_b = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_beta.molden')
                molden.from_mo(mol, molden_file_b, nto_coeff[1])
                print(f"  Beta NTO orbitals saved to: {molden_file_b}")
            else:
                # RKS case
                molden_file = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}.molden')
                molden.from_mo(mol, molden_file, nto_coeff)
                print(f"  NTO orbitals saved to: {molden_file}")
    
    print("="*70)
else:
    print("\nNTO analysis disabled.")

# ============================================================================
# 6A. TRANSITION CONTRIBUTION ANALYSIS
# ============================================================================

if ENABLE_CONTRIBUTION_ANALYSIS:
    print("\n" + "="*70)
    print("TRANSITION CONTRIBUTION ANALYSIS")
    print("="*70)
    print("Analyzing orbital pair contributions to excited states...")
    
    # Filter valid states
    valid_contrib_states = [s for s in CONTRIBUTION_STATES if s < td.nstates]
    
    if not valid_contrib_states:
        print("No valid states selected for contribution analysis.")
    else:
        # Store all contributions for summary
        all_contributions = {}
        
        for state_id in valid_contrib_states:
            excitation_energy = td.e[state_id] * 27.211  # Convert to eV
            
            # Analyze contributions
            contributions, total_weight = analyze_transition_contributions(
                td, state_id, mf,
                threshold=CONTRIBUTION_THRESHOLD,
                top_n=TOP_N_CONTRIBUTIONS
            )
            
            all_contributions[state_id] = (contributions, total_weight)
            
            # Print contribution table
            print(f"\n{'='*70}")
            print(f"STATE {state_id+1}: {excitation_energy:.4f} eV")
            print(f"{'='*70}")
            print(f"{'Rank':<6} {'Transition':<20} {'Weight':<12} {'Percentage':<12} {'Cumulative':<12}")
            print(f"{'-'*70}")
            
            cumulative = 0.0
            for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
                cumulative += weight
                print(f"{rank:<6} {label:<20} {weight:<12.6f} {weight*100:<12.2f}% {cumulative*100:<12.2f}%")
            
            print(f"{'-'*70}")
            print(f"Total weight analyzed: {total_weight:.6f}")
        
        # Save contribution tables to file
        table_file = os.path.join(OUTPUT_DIR, 'contribution_tables.txt')
        with open(table_file, 'w') as f:
            f.write("="*70 + "\n")
            f.write("ORBITAL PAIR CONTRIBUTIONS TO EXCITED STATES\n")
            f.write("="*70 + "\n\n")
            
            for state_id in valid_contrib_states:
                contributions, total_weight = all_contributions[state_id]
                excitation_energy = td.e[state_id] * 27.211
                
                f.write(f"\n{'='*70}\n")
                f.write(f"STATE {state_id+1}: {excitation_energy:.4f} eV\n")
                f.write(f"{'='*70}\n")
                f.write(f"{'Rank':<6} {'Transition':<20} {'Weight':<12} {'Percentage':<12} {'Cumulative':<12}\n")
                f.write(f"{'-'*70}\n")
                
                cumulative = 0.0
                for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
                    cumulative += weight
                    f.write(f"{rank:<6} {label:<20} {weight:<12.6f} {weight*100:<12.2f}% {cumulative*100:<12.2f}%\n")
                
                f.write(f"{'-'*70}\n")
                f.write(f"Total weight analyzed: {total_weight:.6f}\n")
                f.write(f"{'='*70}\n\n")
        
        print(f"\n✓ Contribution tables saved to: {table_file}")
        
        # Generate cube files for dominant orbital pairs
        if GENERATE_PAIR_CUBES:
            print(f"\n{'='*70}")
            print("GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES")
            print(f"{'='*70}")
            print("Note: Cube files will be generated after grid parameters are calculated")
            print("      (see CUBE FILE GENERATION section below)")
    
    print("="*70)
else:
    print("\nTransition contribution analysis disabled.")

# ============================================================================
# 7. CALCULATE GRID PARAMETERS
# ============================================================================

def calculate_grid_parameters(mol, use_resolution=True, resolution=None, 
                             box_margin=4.0, grid_spacing=0.2):
    """
    Calculate grid parameters for cube file generation.
    
    Parameters:
    -----------
    mol : Mole object
    use_resolution : bool
        If True, use fixed resolution. If False, calculate from box dimensions.
    resolution : list [nx, ny, nz]
        Grid resolution (number of points per axis)
    box_margin : float
        Margin around molecule in Angstrom
    grid_spacing : float
        Grid spacing in Angstrom
    
    Returns:
    --------
    nx, ny, nz : int
        Grid resolution
    box_info : dict
        Box dimension information
    """
    # Get molecular coordinates in Angstrom
    coords = mol.atom_coords() * 0.529177  # Bohr to Angstrom
    
    # Calculate bounding box
    min_coords = coords.min(axis=0)
    max_coords = coords.max(axis=0)
    mol_size = max_coords - min_coords
    
    box_info = {
        'min_coords': min_coords,
        'max_coords': max_coords,
        'mol_size': mol_size,
        'box_margin': box_margin
    }
    
    if use_resolution:
        nx, ny, nz = resolution
        actual_spacing = mol_size / np.array([nx, ny, nz])
        box_info['grid_spacing'] = actual_spacing
        box_info['total_points'] = nx * ny * nz
    else:
        # Calculate grid points from spacing and box size
        box_size = mol_size + 2 * box_margin
        nx = int(np.ceil(box_size[0] / grid_spacing))
        ny = int(np.ceil(box_size[1] / grid_spacing))
        nz = int(np.ceil(box_size[2] / grid_spacing))
        box_info['grid_spacing'] = [grid_spacing] * 3
        box_info['box_size'] = box_size
        box_info['total_points'] = nx * ny * nz
    
    return nx, ny, nz, box_info

# Calculate grid parameters
print("\n" + "="*70)
print("GRID PARAMETERS")
print("="*70)

if USE_GRID_RESOLUTION:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=True, resolution=GRID_RESOLUTION
    )
    print(f"Using fixed grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Molecule size: {box_info['mol_size']} Å")
    print(f"Effective grid spacing: {box_info['grid_spacing']} Å")
else:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=False, box_margin=BOX_MARGIN, 
        grid_spacing=GRID_SPACING
    )
    print(f"Using box dimensions with margin: {BOX_MARGIN} Å")
    print(f"Grid spacing: {GRID_SPACING} Å")
    print(f"Calculated grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Box size: {box_info['box_size']} Å")

print("="*70)

# ============================================================================
# 8. GENERATE HOMO/LUMO CUBE FILES
# ============================================================================

if GENERATE_HOMO_LUMO:
    print("\n" + "="*70)
    print("GENERATING HOMO/LUMO CUBE FILES")
    print("="*70)
    
    # Get HOMO and LUMO indices (handle both RKS and UKS)
    if actual_spin == 1:  # RKS (closed-shell)
        mo_occ = mf.mo_occ
        mo_coeff = mf.mo_coeff
        mo_energy = mf.mo_energy
    else:  # UKS (open-shell) - use alpha orbitals
        mo_occ = mf.mo_occ[0]  # Alpha occupation
        mo_coeff = mf.mo_coeff[0]  # Alpha coefficients
        mo_energy = mf.mo_energy[0]  # Alpha energies
        print("Note: Using alpha orbitals for HOMO/LUMO (open-shell system)")
    
    # Convert CuPy to NumPy if needed
    if hasattr(mo_occ, 'get'):
        mo_occ = mo_occ.get()
        mo_coeff = mo_coeff.get()
        mo_energy = mo_energy.get()
    
    homo_idx = np.where(mo_occ > 0)[0][-1]
    lumo_idx = np.where(mo_occ == 0)[0][0]
    
    print(f"HOMO index: {homo_idx}")
    print(f"LUMO index: {lumo_idx}")
    print(f"HOMO energy: {mo_energy[homo_idx]*27.211:.3f} eV")
    print(f"LUMO energy: {mo_energy[lumo_idx]*27.211:.3f} eV")
    print(f"HOMO-LUMO gap: {(mo_energy[lumo_idx] - mo_energy[homo_idx])*27.211:.3f} eV")
    
    # Generate HOMO cube file
    homo_file = os.path.join(OUTPUT_DIR, 'HOMO.cube')
    cubegen.orbital(mol, homo_file, mo_coeff[:, homo_idx], nx=nx, ny=ny, nz=nz)
    print(f"\n  ✓ HOMO orbital: {homo_file}")
    
    # Generate LUMO cube file
    lumo_file = os.path.join(OUTPUT_DIR, 'LUMO.cube')
    cubegen.orbital(mol, lumo_file, mo_coeff[:, lumo_idx], nx=nx, ny=ny, nz=nz)
    print(f"  ✓ LUMO orbital: {lumo_file}")
    
    # Generate HOMO-1 and LUMO+1 for additional verification
    if homo_idx > 0:
        homo1_file = os.path.join(OUTPUT_DIR, 'HOMO-1.cube')
        cubegen.orbital(mol, homo1_file, mo_coeff[:, homo_idx-1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ HOMO-1 orbital: {homo1_file}")
    
    if lumo_idx < len(mo_occ) - 1:
        lumo1_file = os.path.join(OUTPUT_DIR, 'LUMO+1.cube')
        cubegen.orbital(mol, lumo1_file, mo_coeff[:, lumo_idx+1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ LUMO+1 orbital: {lumo1_file}")
    
    print("\nVerification tip:")
    print("For the first excited state (S1), check if the transition density")
    print("resembles a HOMO→LUMO transition by comparing:")
    print("  - transition_density_state1.cube")
    print("  - HOMO.cube (electron depletion)")
    print("  - LUMO.cube (electron accumulation)")
    
    # Analytical verification: Calculate HOMO→LUMO transition density
    print("\n" + "-"*70)
    print("ANALYTICAL VERIFICATION: HOMO→LUMO Transition Density")
    print("-"*70)
    
    # Construct approximate HOMO→LUMO transition density matrix
    homo_mo = mo_coeff[:, homo_idx]
    lumo_mo = mo_coeff[:, lumo_idx]
    
    # T_approx = |HOMO⟩⟨LUMO| + |LUMO⟩⟨HOMO|
    # In AO basis: T_μν = C_μ^HOMO * C_ν^LUMO + C_μ^LUMO * C_ν^HOMO
    t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
    
    # Generate cube file for HOMO→LUMO transition density
    homo_lumo_file = os.path.join(OUTPUT_DIR, 'transition_HOMO_LUMO_analytical.cube')
    cubegen.density(mol, homo_lumo_file, t_homo_lumo, nx=nx, ny=ny, nz=nz)
    print(f"  ✓ Analytical HOMO→LUMO transition: {homo_lumo_file}")
    
    print("\nTo verify S1 is a HOMO→LUMO transition, compare:")
    print(f"  1. {os.path.join(OUTPUT_DIR, 'transition_density_state1.cube')}")
    print(f"  2. {homo_lumo_file}")
    print("\nThey should be very similar if S1 is dominated by HOMO→LUMO excitation.")
    print("You can calculate the overlap/similarity in VMD or by visual inspection.")
    
    print("="*70)
else:
    print("\nHOMO/LUMO generation disabled.")

# ============================================================================
# 9. GENERATE CUBE FILES FOR SELECTED EXCITED STATES
# ============================================================================

print("\n" + "="*70)
print("GENERATING EXCITED STATE CUBE FILES")
print("="*70)

# Filter valid states
valid_states = [s for s in STATES_TO_OUTPUT if s < td.nstates]

if not valid_states:
    print("No valid states selected for cube file generation.")
else:
    print(f"Generating cube files for states: {[s+1 for s in valid_states]}")
    print(f"Grid resolution: {nx} × {ny} × {nz}")
    
    for state_id in valid_states:
        print(f"\nState {state_id+1}: {td.e[state_id]*27.211:.3f} eV")
        
        # 1. Transition density matrix
        if GENERATE_TRANSITION_DENSITY:
            dm_trans = calculate_transition_density_matrix(td, state_id)
            filename_trans = os.path.join(OUTPUT_DIR, f'transition_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_trans, dm_trans, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Transition density: {filename_trans}")
        
        # 2. Excited state density
        if GENERATE_EXCITED_DENSITY:
            dm_excited = calculate_excited_state_density(td, state_id)
            filename_excited = os.path.join(OUTPUT_DIR, f'excited_state_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_excited, dm_excited, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Excited state density: {filename_excited}")
        
        # 3. Density difference
        if GENERATE_DENSITY_DIFFERENCE:
            if not GENERATE_EXCITED_DENSITY:
                dm_excited = calculate_excited_state_density(td, state_id)
            
            # Get ground state density and convert CuPy to NumPy if needed
            dm_ground = mf.make_rdm1()
            if hasattr(dm_ground, 'get'):
                dm_ground = dm_ground.get()
            
            # For UKS, dm_ground is a tuple (alpha, beta), sum them
            if isinstance(dm_ground, tuple):
                dm_ground = dm_ground[0] + dm_ground[1]
            
            dm_diff = dm_excited - dm_ground
            filename_diff = os.path.join(OUTPUT_DIR, f'density_difference_state{state_id+1}.cube')
            cubegen.density(mol, filename_diff, dm_diff, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Density difference: {filename_diff}")
        
        # Quantitative verification for first state
        if state_id == 0 and GENERATE_HOMO_LUMO and GENERATE_TRANSITION_DENSITY:
            print("\n  " + "-"*66)
            print("  QUANTITATIVE VERIFICATION: S1 vs HOMO→LUMO")
            print("  " + "-"*66)
            
            # Get HOMO and LUMO indices (handle both RKS and UKS)
            if actual_spin == 1:
                mo_occ_ver = mf.mo_occ
                mo_coeff_ver = mf.mo_coeff
            else:
                mo_occ_ver = mf.mo_occ[0]
                mo_coeff_ver = mf.mo_coeff[0]
            
            # Convert CuPy to NumPy if needed
            if hasattr(mo_occ_ver, 'get'):
                mo_occ_ver = mo_occ_ver.get()
                mo_coeff_ver = mo_coeff_ver.get()
            
            homo_idx = np.where(mo_occ_ver > 0)[0][-1]
            lumo_idx = np.where(mo_occ_ver == 0)[0][0]
            
            # Calculate analytical HOMO→LUMO transition density
            homo_mo = mo_coeff_ver[:, homo_idx]
            lumo_mo = mo_coeff_ver[:, lumo_idx]
            t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
            
            # Get TDDFT transition density for S1
            dm_trans_s1 = calculate_transition_density_matrix(td, 0)
            
            # Calculate overlap/similarity (Frobenius inner product)
            overlap = np.sum(dm_trans_s1 * t_homo_lumo)
            norm_tddft = np.linalg.norm(dm_trans_s1)
            norm_homo_lumo = np.linalg.norm(t_homo_lumo)
            similarity = overlap / (norm_tddft * norm_homo_lumo)
            
            # Calculate HOMO→LUMO contribution from TDDFT amplitudes
            X, Y = td.xy[0]
            
            # For UKS, X and Y are tuples (Xa, Xb), (Ya, Yb)
            if actual_spin > 1:
                Xa, Xb = X
                Ya, Yb = Y
                # Convert CuPy to NumPy if needed
                if hasattr(Xa, 'get'):
                    Xa = Xa.get()
                    Ya = Ya.get()
                # Use only alpha part for verification
                # HOMO is last occupied (nocc_a-1), LUMO is first virtual (0)
                homo_lumo_amplitude = abs(Xa[-1, 0] + Ya[-1, 0])
                total_amplitude = np.linalg.norm(Xa + Ya)
            else:
                # Convert CuPy to NumPy if needed
                if hasattr(X, 'get'):
                    X = X.get()
                    Y = Y.get()
                nocc = X.shape[0]
                nvir = X.shape[1]
                # HOMO is index nocc-1 in occupied space, LUMO is index 0 in virtual space
                homo_lumo_amplitude = abs(X[nocc-1, 0] + Y[nocc-1, 0])
                total_amplitude = np.linalg.norm(X + Y)
            
            homo_lumo_weight = (homo_lumo_amplitude / total_amplitude)**2
            
            print(f"  Similarity (cosine): {similarity:.4f}")
            print(f"  HOMO→LUMO weight: {homo_lumo_weight:.4f} ({homo_lumo_weight*100:.1f}%)")
            print(f"  HOMO→LUMO amplitude: {homo_lumo_amplitude:.4f}")
            
            if similarity > 0.95 and homo_lumo_weight > 0.8:
                print("  ✓ S1 is STRONGLY dominated by HOMO→LUMO transition")
            elif similarity > 0.85 and homo_lumo_weight > 0.6:
                print("  ✓ S1 is MOSTLY a HOMO→LUMO transition")
            elif similarity > 0.70 and homo_lumo_weight > 0.4:
                print("  ⚠ S1 has SIGNIFICANT HOMO→LUMO character but mixed")
            else:
                print("  ⚠ S1 is NOT a pure HOMO→LUMO transition (multi-configurational)")
            
            print("  " + "-"*66)

print("="*70)

# ============================================================================
# 9A. GENERATE ORBITAL PAIR TRANSITION DENSITY CUBE FILES
# ============================================================================

if ENABLE_CONTRIBUTION_ANALYSIS and GENERATE_PAIR_CUBES and 'all_contributions' in locals():
    print("\n" + "="*70)
    print("GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES")
    print("="*70)
    
    for state_id in valid_contrib_states:
        if state_id not in all_contributions:
            continue
        
        contributions, _ = all_contributions[state_id]
        excitation_energy = td.e[state_id] * 27.211
        
        print(f"\nState {state_id+1} ({excitation_energy:.4f} eV):")
        
        pair_count = 0
        for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
            if pair_count >= MAX_PAIRS_PER_STATE:
                break
            
            if weight < PAIR_CONTRIBUTION_CUTOFF:
                print(f"  Skipping {label} (contribution {weight*100:.2f}% < {PAIR_CONTRIBUTION_CUTOFF*100:.0f}%)")
                continue
            
            # Calculate transition density for this pair
            t_dm_pair = calculate_pair_transition_density(mf, occ_idx, vir_idx)
            
            # Generate cube file
            labels, _ = get_orbital_labels(mf)
            occ_label = labels[occ_idx].replace('-', 'm').replace('+', 'p')
            vir_label = labels[vir_idx].replace('-', 'm').replace('+', 'p')
            
            filename = os.path.join(OUTPUT_DIR, 
                f'transition_pair_state{state_id+1}_{occ_label}_to_{vir_label}.cube')
            
            cubegen.density(mol, filename, t_dm_pair, nx=nx, ny=ny, nz=nz)
            
            print(f"  ✓ Rank {rank}: {label} ({weight*100:.2f}%) → {filename}")
            pair_count += 1
    
    print("="*70)

# ============================================================================
# 10. CALCULATION SUMMARY
# ============================================================================

print("\n" + "="*70)
print("CALCULATION SUMMARY")
print("="*70)

print(f"\nMolecule: {'XYZ file: ' + XYZ_FILE if USE_XYZ else 'H2O test molecule'}")
print(f"Basis set: {BASIS_SET}")
print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity: {actual_spin} ({'closed-shell' if actual_spin == 1 else 'open-shell'})")

print(f"\nComputational settings:")
print(f"  DFT method: {dft_method}")
print(f"  XC functional: {XC_FUNCTIONAL}")
print(f"  Parallel threads: {NUM_THREADS if NUM_THREADS > 0 else 'auto-detected'}")
print(f"  TDDFT method: Full TDDFT (not TDA)")
print(f"  Number of excited states calculated: {NUM_EXCITED_STATES}")

print(f"\nGrid settings:")
if USE_GRID_RESOLUTION:
    print(f"  Mode: Fixed resolution")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")
else:
    print(f"  Mode: Box dimensions")
    print(f"  Margin: {BOX_MARGIN} Å, Spacing: {GRID_SPACING} Å")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")

print(f"\nOutput files generated:")
if GENERATE_HOMO_LUMO:
    print(f"  ✓ HOMO/LUMO orbitals (in {OUTPUT_DIR}/)")
if ENABLE_NTO_ANALYSIS and valid_nto_states:
    print(f"  ✓ NTO analysis for {len(valid_nto_states)} state(s)")
if valid_states:
    print(f"  ✓ Cube files for {len(valid_states)} state(s):")
    if GENERATE_TRANSITION_DENSITY:
        print(f"    - Transition density matrices")
    if GENERATE_EXCITED_DENSITY:
        print(f"    - Excited state densities")
    if GENERATE_DENSITY_DIFFERENCE:
        print(f"    - Density differences")

print(f"\nAll output files saved to: {OUTPUT_DIR}/")

print("\n" + "="*70)
print("VISUALIZATION GUIDE")
print("="*70)
print("""
Three types of cube files generated:

1. transition_density_state*.cube
   - Represents the electronic transition between ground and excited state
   - Used for calculating transition dipole moments
   - Visualize with isovalues ±0.002

2. excited_state_density_state*.cube
   - Total electron density in the excited state
   - Compare with ground state density

3. density_difference_state*.cube
   - Change in electron density (excited - ground)
   - Red/positive: electron accumulation
   - Blue/negative: electron depletion
   - Recommended for visualization

VMD visualization:
  vmd output/density_difference_state1.cube
  Graphics > Representations > Drawing Method: Isosurface
  - Rep 1: Isovalue = +0.002, Color = Red (electron gain)
  - Rep 2: Isovalue = -0.002, Color = Blue (electron loss)

Jmol visualization:
  isosurface ID "surf1" cutoff  0.002 output/density_difference_state1.cube
  isosurface ID "surf2" cutoff -0.002 output/density_difference_state1.cube

HOMO/LUMO verification:
  Compare transition_density_state1.cube with HOMO.cube and LUMO.cube
  to verify that S1 corresponds to a HOMO→LUMO transition.

NTO visualization:
  Open output/nto_state_*.molden files in Jmol, Avogadro, or VMD
""")
print("="*70)

print("\n✓ Calculation completed successfully!")
print(f"✓ All files saved to: {OUTPUT_DIR}/\n")
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='DesktopGTX3060', release='5.15.0-161-generic', version='#171-Ubuntu SMP Sat Oct 11 08:17:01 UTC 2025', machine='x86_64')  Threads 12
Python 3.10.12 (main, Aug 15 2025, 14:32:43) [GCC 11.4.0]
numpy 1.26.4  scipy 1.11.4  h5py 3.15.1
Date: Tue Nov 18 14:28:07 2025
PySCF version 2.11.0
PySCF path  /home/indranil/.local/lib/python3.10/site-packages/pyscf/__init__.py
CUDA Environment
    CuPy 13.4.1
    CUDA Path /usr
    CUDA Build Version 12080
    CUDA Driver Version 12090
    CUDA Runtime Version 12080
CUDA toolkit
    cuSolver (11, 7, 4)
    cuBLAS 120900
    cuTENSOR 20301
Device info
    Device name b'NVIDIA GeForce RTX 3060'
    Device global memory 11.63 GB
    CuPy memory fraction 0.9
    Num. Devices 1
GPU4PySCF 1.4.3
GPU4PySCF path  /home/indranil/.local/lib/python3.10/site-packages/gpu4pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 38
[INPUT] num. electrons = 199
[INPUT] charge = 1
[INPUT] spin (= nelec alpha-beta = 2S) = 1
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 C      2.896522000000   0.014575000000   0.000000000000 AA    5.473633293777   0.027542758266   0.000000000000 Bohr   0.0
[INPUT]  2 C     -3.625534000000  -1.241935000000   0.000000000000 AA   -6.851266315299  -2.346917014512   0.000000000000 Bohr   0.0
[INPUT]  3 C      1.437634000000   0.009164000000   0.000000000000 AA    2.716734527363   0.017317450206   0.000000000000 Bohr   0.0
[INPUT]  4 C     -2.895730000000  -0.014912000000   0.000000000000 AA   -5.472136630687  -0.028179595970   0.000000000000 Bohr   0.0
[INPUT]  5 C      0.729281000000  -1.249862000000   0.000000000000 AA    1.378141357849  -2.361896873501   0.000000000000 Bohr   0.0
[INPUT]  6 C     -0.727755000000  -1.261619000000   0.000000000000 AA   -1.375257635783  -2.384114383548   0.000000000000 Bohr   0.0
[INPUT]  7 C     -1.436957000000  -0.009874000000   0.000000000000 AA   -2.715455182777  -0.018659155754   0.000000000000 Bohr   0.0
[INPUT]  8 C      3.626674000000   1.242670000000   0.000000000000 AA    6.853420603081   2.348305963213   0.000000000000 Bohr   0.0
[INPUT]  9 C      0.728503000000   1.260811000000   0.000000000000 AA    1.376671150924   2.382587484839   0.000000000000 Bohr   0.0
[INPUT] 10 C     -5.092425000000  -1.228040000000   0.000000000000 AA   -9.623288559888  -2.320659270011   0.000000000000 Bohr   0.0
[INPUT] 11 C     -0.728118000000   1.249065000000   0.000000000000 AA   -1.375943606366   2.360390761780   0.000000000000 Bohr   0.0
[INPUT] 12 C     -5.057623000000   1.241537000000   0.000000000000 AA   -9.557522311301   2.346164903514   0.000000000000 Bohr   0.0
[INPUT] 13 C     -2.901906000000  -2.476606000000   0.000000000000 AA   -5.483807579232  -4.680107058455   0.000000000000 Bohr   0.0
[INPUT] 14 C      3.601221000000  -1.226169000000   0.000000000000 AA    6.805321404032  -2.317123592432   0.000000000000 Bohr   0.0
[INPUT] 15 C      1.487021000000  -2.470749000000   0.000000000000 AA    2.810062431477  -4.669038932543   0.000000000000 Bohr   0.0
[INPUT] 16 C      2.901581000000   2.477708000000   0.000000000000 AA    5.483193418242   4.682189536644   0.000000000000 Bohr   0.0
[INPUT] 17 C      5.092590000000   1.230486000000   0.000000000000 AA    9.623600364699   2.325281540112   0.000000000000 Bohr   0.0
[INPUT] 18 C     -1.492998000000  -2.485108000000   0.000000000000 AA   -2.821357324523  -4.696173509966   0.000000000000 Bohr   0.0
[INPUT] 19 C      5.056187000000  -1.242165000000   0.000000000000 AA    9.554808664586  -2.347351651520   0.000000000000 Bohr   0.0
[INPUT] 20 C      1.493062000000   2.485432000000   0.000000000000 AA    2.821478266995   4.696785781230   0.000000000000 Bohr   0.0
[INPUT] 21 C     -3.601702000000   1.225997000000   0.000000000000 AA   -6.806230362298   2.316798559538   0.000000000000 Bohr   0.0
[INPUT] 22 C      2.893134000000  -2.460012000000   0.000000000000 AA    5.467230901667  -4.648748943144   0.000000000000 Bohr   0.0
[INPUT] 23 C     -1.485604000000   2.469918000000   0.000000000000 AA   -2.807384689558   4.667468570133   0.000000000000 Bohr   0.0
[INPUT] 24 C     -2.893236000000   2.458717000000   0.000000000000 AA   -5.467423653732   4.646301747812   0.000000000000 Bohr   0.0
[INPUT] 25 O     -5.732320000000   0.026109000000   0.000000000000 AA  -10.832514858367   0.049338859386   0.000000000000 Bohr   0.0
[INPUT] 26 O      5.734140000000  -0.025581000000   0.000000000000 AA   10.835954159914  -0.048341083992   0.000000000000 Bohr   0.0
[INPUT] 27 O     -5.767539000000   2.259992000000   0.000000000000 AA  -10.899069122748   4.270765923708   0.000000000000 Bohr   0.0
[INPUT] 28 O     -5.856852000000  -2.197455000000   0.000000000000 AA  -11.067846232111  -4.152588121056   0.000000000000 Bohr   0.0
[INPUT] 29 O      5.766769000000  -2.260350000000   0.000000000000 AA   10.897614033632  -4.271442445661   0.000000000000 Bohr   0.0
[INPUT] 30 O      5.853157000000   2.198203000000   0.000000000000 AA   11.060863694081   4.154001636197   0.000000000000 Bohr   0.0
[INPUT] 31 H      0.966973000000  -3.439928000000   0.000000000000 AA    1.827314139849  -6.500521808223   0.000000000000 Bohr   0.0
[INPUT] 32 H     -3.465927000000  -3.425329000000   0.000000000000 AA   -6.549652797735  -6.472933696530   0.000000000000 Bohr   0.0
[INPUT] 33 H     -0.969686000000  -3.454698000000   0.000000000000 AA   -1.832440966825  -6.528433063083   0.000000000000 Bohr   0.0
[INPUT] 34 H      0.969067000000   3.454476000000   0.000000000000 AA    1.831271226354   6.528013543883   0.000000000000 Bohr   0.0
[INPUT] 35 H      3.465022000000   3.426681000000   0.000000000000 AA    6.547942595593   6.475488606251   0.000000000000 Bohr   0.0
[INPUT] 36 H      3.481146000000  -3.397659000000   0.000000000000 AA    6.578412539625  -6.420644974664   0.000000000000 Bohr   0.0
[INPUT] 37 H     -0.966845000000   3.439743000000   0.000000000000 AA   -1.827072254905   6.500172208890   0.000000000000 Bohr   0.0
[INPUT] 38 H     -3.480925000000   3.396767000000   0.000000000000 AA   -6.577994910152   6.418959338960   0.000000000000 Bohr   0.0

nuclear repulsion = 2584.1133492772
number of shells = 166
number of NR pGTOs = 692
number of NR cGTOs = 286
basis = 6-31g
ecp = {}
CPU time:         2.58
Number of atoms: 38
Number of electrons: 199
Number of basis functions: 286
Molecular charge: 1
Spin multiplicity (2S+1): 2
Number of unpaired electrons (2S): 1
System type: Open-shell (doublet)
DFT method: UKS (GPU-accelerated)

======================================================================
GROUND STATE DFT CALCULATION
======================================================================
XC functional: b3lyp
Basis set: 6-31g
Method: UKS (GPU-accelerated)
XC library gpu4pyscf.dft.libxc version 7.0.0 (CUDA)
    unable to decode the reference due to https://github.com/NVIDIA/cuda-python/issues/29
XC functionals = b3lyp
radial grids: 
    Treutler-Ahlrichs [JCP 102, 346 (1995); DOI:10.1063/1.469408] (M4) radial grids
    
becke partition: Becke, JCP 88, 2547 (1988); DOI:10.1063/1.454033
pruning grids: <function nwchem_prune at 0x7fcd90b2d6c0>
grids dens level: 3
symmetrized grids: False
atomic radii adjust function: <function treutler_atomic_radii_adjust at 0x7fcd90b2d510>
small_rho_cutoff = 1e-07
Set gradient conv threshold to 3.16228e-05
tot grids = 502016
init E= -1376.38324328275
  alpha nocc = 100  HOMO = -0.24153753665407  LUMO = -0.186194043847459
  beta  nocc = 99  HOMO = -0.284796048231548  LUMO = -0.24153753665407

WARN: system HOMO -0.24153753665407 >= system LUMO -0.24153753665407

cycle= 1 E= -1369.26925411002  delta_E= 7.11  |g|= 1.34  |ddm|= 5.65
  alpha nocc = 100  HOMO = -0.283255870732844  LUMO = -0.278130558595241
  beta  nocc = 99  HOMO = -0.283724467788075  LUMO = -0.282665309982387

WARN: system HOMO -0.282665309982387 >= system LUMO -0.282665309982387

cycle= 2 E= -1359.20566843489  delta_E= 10.1  |g|= 4.13  |ddm|= 6.87
  alpha nocc = 100  HOMO = -0.343777315245173  LUMO = -0.275093750177618
  beta  nocc = 99  HOMO = -0.353466567391029  LUMO = -0.319047974777356
cycle= 3 E= -1369.64429406835  delta_E= -10.4  |g|= 0.856  |ddm|= 6.26
  alpha nocc = 100  HOMO = -0.372340894477145  LUMO = -0.299130996284627
  beta  nocc = 99  HOMO = -0.394740482934492  LUMO = -0.34407384129149
cycle= 4 E= -1370.07957262026  delta_E= -0.435  |g|= 0.249  |ddm|= 1.31
  alpha nocc = 100  HOMO = -0.390098447817153  LUMO = -0.305156662751534
  beta  nocc = 99  HOMO = -0.409130697163186  LUMO = -0.352308210225074
cycle= 5 E= -1370.0738778741  delta_E= 0.00569  |g|= 0.263  |ddm|= 0.718
  alpha nocc = 100  HOMO = -0.386773997116003  LUMO = -0.302925861319984
  beta  nocc = 99  HOMO = -0.408865633870875  LUMO = -0.345998825061633
cycle= 6 E= -1370.11397825434  delta_E= -0.0401  |g|= 0.0483  |ddm|= 0.395
  alpha nocc = 100  HOMO = -0.383578961852626  LUMO = -0.298777230871753
  beta  nocc = 99  HOMO = -0.410755959990731  LUMO = -0.341464170283438
cycle= 7 E= -1370.11517767008  delta_E= -0.0012  |g|= 0.022  |ddm|= 0.084
  alpha nocc = 100  HOMO = -0.384080703574453  LUMO = -0.298678795382455
  beta  nocc = 99  HOMO = -0.411247392739659  LUMO = -0.340871140695263
cycle= 8 E= -1370.11542451603  delta_E= -0.000247  |g|= 0.00745  |ddm|= 0.0313
  alpha nocc = 100  HOMO = -0.384525084116103  LUMO = -0.298811487829891
  beta  nocc = 99  HOMO = -0.411639871027068  LUMO = -0.340645794110109
cycle= 9 E= -1370.11547506638  delta_E= -5.06e-05  |g|= 0.0052  |ddm|= 0.0154
  alpha nocc = 100  HOMO = -0.384992847649069  LUMO = -0.299023579730163
  beta  nocc = 99  HOMO = -0.411752362546537  LUMO = -0.340424276320741
cycle= 10 E= -1370.11550824448  delta_E= -3.32e-05  |g|= 0.00412  |ddm|= 0.0131
  alpha nocc = 100  HOMO = -0.385228356838674  LUMO = -0.299038617021895
  beta  nocc = 99  HOMO = -0.41174832806531  LUMO = -0.34000245854846
cycle= 11 E= -1370.11553116594  delta_E= -2.29e-05  |g|= 0.00169  |ddm|= 0.0117
  alpha nocc = 100  HOMO = -0.38527766302508  LUMO = -0.299030453353277
  beta  nocc = 99  HOMO = -0.411535426614052  LUMO = -0.339840456851912
cycle= 12 E= -1370.1155355093  delta_E= -4.34e-06  |g|= 0.00114  |ddm|= 0.00497
  alpha nocc = 100  HOMO = -0.385405498785304  LUMO = -0.29907114661764
  beta  nocc = 99  HOMO = -0.411577032601843  LUMO = -0.339697686167782
cycle= 13 E= -1370.11553787387  delta_E= -2.36e-06  |g|= 0.000603  |ddm|= 0.00539
  alpha nocc = 100  HOMO = -0.385440446728179  LUMO = -0.299103948129703
  beta  nocc = 99  HOMO = -0.411568998023186  LUMO = -0.339704260650164
cycle= 14 E= -1370.11553812186  delta_E= -2.48e-07  |g|= 0.000185  |ddm|= 0.00111
  alpha nocc = 100  HOMO = -0.385440453904168  LUMO = -0.299115353473924
  beta  nocc = 99  HOMO = -0.411547602116837  LUMO = -0.339717187716273
cycle= 15 E= -1370.11553811849  delta_E= 3.37e-09  |g|= 0.000258  |ddm|= 0.000646
  alpha nocc = 100  HOMO = -0.38543489396387  LUMO = -0.29910741803899
  beta  nocc = 99  HOMO = -0.411549848474254  LUMO = -0.33970950029539
cycle= 16 E= -1370.11553815863  delta_E= -4.01e-08  |g|= 9.36e-05  |ddm|= 0.00043
  alpha nocc = 100  HOMO = -0.385437451858901  LUMO = -0.299107907102629
  beta  nocc = 99  HOMO = -0.41154738034423  LUMO = -0.339706379615638
cycle= 17 E= -1370.11553816152  delta_E= -2.89e-09  |g|= 6.61e-05  |ddm|= 0.000208
  alpha nocc = 100  HOMO = -0.38543612951262  LUMO = -0.299107405897094
  beta  nocc = 99  HOMO = -0.411549603602518  LUMO = -0.339707566205169
cycle= 18 E= -1370.11553816403  delta_E= -2.51e-09  |g|= 3.52e-05  |ddm|= 0.000116
  alpha nocc = 100  HOMO = -0.385436122801776  LUMO = -0.299108115144857
  beta  nocc = 99  HOMO = -0.411549140475209  LUMO = -0.339709286332682
cycle= 19 E= -1370.11553816487  delta_E= -8.41e-10  |g|= 1.85e-05  |ddm|= 7.03e-05
converged SCF energy = -1370.11553816487  <S^2> = 0.78999308  2S+1 = 2.039601
✓ SCF converged
Ground state energy: -1370.115538 a.u.

======================================================================
TDDFT CALCULATION
======================================================================
Note: TDDFT inherits XC functional (b3lyp) and basis set (6-31g) from ground state
TDDFT method: TDDFT (UKS-based, GPU-accelerated)
Using full TDDFT - more accurate but slower
Calculating 10 excited states...


******** <class 'gpu4pyscf.tdscf.uks.TDDFT'> for <class 'gpu4pyscf.dft.uks.UKS'> ********
nstates = 10
deg_eia_thresh = 1.000e-03
wfnsym = None
conv_tol = 1e-05
eigh lindep = 1e-12
eigh level_shift = 0
eigh max_cycle = 100
chkfile = None
max_memory 4000 MB (current use 1434 MB)


Excited State energies (eV)
[1.17943651 1.18316842 1.43209478 1.65587691 1.80361523 1.80558055
 1.91676084 1.92625716 2.02356409 2.22068697]
✓ TDDFT converged (all states)

** Excitation energies and oscillator strengths **
Excited State   1:      1.17944 eV   1051.22 nm  f=0.0000
      98b ->  100b     -0.16895
      98b ->  101b     -0.21809
      99b ->  100b      0.94923
Excited State   2:      1.18317 eV   1047.90 nm  f=0.0000
      98b ->  100b     -0.94893
      99b ->  100b     -0.16890
      99b ->  101b      0.21914
Excited State   3:      1.43209 eV    865.75 nm  f=0.0029
     100a ->  101a     -0.76593
      96b ->  100b      0.39178
      97b ->  100b      0.49730
Excited State   4:      1.65588 eV    748.75 nm  f=0.0044
     100a ->  101a     -0.10532
      94b ->  101b      0.10851
      95b ->  100b      0.56107
      96b ->  100b      0.55594
      97b ->  100b     -0.57238
Excited State   5:      1.80362 eV    687.42 nm  f=0.0211
      91a ->  101a     -0.10416
      96a ->  101a     -0.10941
      91b ->  100b     -0.27417
      94b ->  100b     -0.52781
      95b ->  100b      0.63264
      96b ->  100b     -0.29338
      97b ->  100b      0.31398
Excited State   6:      1.80558 eV    686.67 nm  f=0.0129
      91b ->  100b     -0.35061
      94b ->  100b     -0.68944
      95b ->  100b     -0.48293
      96b ->  100b      0.23431
      97b ->  100b     -0.24025
Excited State   7:      1.91676 eV    646.84 nm  f=0.0000
      92b ->  101b     -0.10897
      93b ->  100b      0.95554
      93b ->  101b     -0.19116
Excited State   8:      1.92626 eV    643.65 nm  f=0.0000
      92b ->  100b     -0.95535
      92b ->  101b     -0.19103
      93b ->  101b      0.11052
Excited State   9:      2.02356 eV    612.70 nm  f=0.0001
      92a ->  101a     -0.21299
     100a ->  102a      0.14601
      91b ->  100b      0.81219
      94b ->  100b     -0.42378
      96b ->  101b     -0.11891
      97b ->  101b      0.15174
Excited State  10:      2.22069 eV    558.31 nm  f=0.5635
     100a ->  101a     -0.57714
      90b ->  100b      0.29389
      96b ->  100b     -0.56621
      97b ->  100b     -0.46923

** Transition electric dipole moments (AU) **
state          X           Y           Z        Dip. S.      Osc.
  1         0.0000     -0.0000      0.0025      0.0000      0.0000
  2         0.0000      0.0000      0.0305      0.0009      0.0000
  3        -0.2802     -0.0619      0.0000      0.0823      0.0029
  4        -0.2031      0.2612     -0.0000      0.1095      0.0044
  5         0.1253     -0.6793     -0.0000      0.4772      0.0211
  6        -0.0915      0.5327      0.0000      0.2921      0.0129
  7        -0.0000     -0.0000      0.0046      0.0000      0.0000
  8        -0.0000      0.0000      0.0029      0.0000      0.0000
  9         0.0339     -0.0060     -0.0000      0.0012      0.0001
 10        -3.2180     -0.0403     -0.0000     10.3572      0.5635

** Transition velocity dipole moments (imaginary part, AU) **
state          X           Y           Z        Dip. S.      Osc.
  1         0.0000     -0.0000      0.0002      0.0000      0.0000
  2         0.0000      0.0000      0.0022      0.0000      0.0001
  3        -0.0177     -0.0024      0.0000      0.0003      0.0040
  4        -0.0110      0.0103      0.0000      0.0002      0.0025
  5         0.0071     -0.0389     -0.0000      0.0016      0.0158
  6        -0.0052      0.0306      0.0000      0.0010      0.0097
  7        -0.0000     -0.0000      0.0012      0.0000      0.0000
  8        -0.0000      0.0000      0.0007      0.0000      0.0000
  9         0.0022     -0.0004     -0.0000      0.0000      0.0000
 10        -0.2222     -0.0036     -0.0000      0.0494      0.4036

** Transition magnetic dipole moments (imaginary part, AU) **
state          X           Y           Z
  1         0.0140     -0.2888     -0.0000
  2         0.0014      0.0240     -0.0000
  3         0.0000      0.0000     -0.0001
  4        -0.0000     -0.0000     -0.0107
  5        -0.0000      0.0000     -0.6237
  6         0.0000     -0.0000     -0.7895
  7         0.1067     -0.0016     -0.0000
  8        -0.1974      0.0037     -0.0000
  9         0.0000      0.0000      0.2688
 10         0.0000      0.0000      0.0018

======================================================================
EXCITED STATE ENERGIES
======================================================================
State 1: 0.043343 a.u. = 1.179 eV
State 2: 0.043481 a.u. = 1.183 eV
State 3: 0.052629 a.u. = 1.432 eV
State 4: 0.060852 a.u. = 1.656 eV
State 5: 0.066282 a.u. = 1.804 eV
State 6: 0.066354 a.u. = 1.806 eV
State 7: 0.070440 a.u. = 1.917 eV
State 8: 0.070789 a.u. = 1.926 eV
State 9: 0.074365 a.u. = 2.024 eV
State 10: 0.081609 a.u. = 2.221 eV
======================================================================

======================================================================
TRANSITION DIPOLE MOMENTS
======================================================================

Transition dipole moments (a.u.):
State    μ_x          μ_y          μ_z          |μ|          f           
----------------------------------------------------------------------
1           0.000000   -0.000000    0.002541    0.002541    0.000000
2           0.000000    0.000000    0.030515    0.030515    0.000027
3          -0.280210   -0.061897    0.000000    0.286965    0.002889
4          -0.203126    0.261238   -0.000000    0.330916    0.004442
5           0.125265   -0.679312   -0.000000    0.690765    0.021084
6          -0.091547    0.532664    0.000000    0.540473    0.012922
7          -0.000000   -0.000000    0.004610    0.004610    0.000001
8          -0.000000    0.000000    0.002869    0.002869    0.000000
9           0.033912   -0.006044   -0.000000    0.034446    0.000059
10         -3.218007   -0.040336   -0.000000    3.218259    0.563492
======================================================================

======================================================================
NATURAL TRANSITION ORBITAL ANALYSIS
======================================================================

State 1 (1.179 eV):
State 1: 1.17944 eV  NTO largest component 0.9398936620304295
    alpha occ-NTO: 0.998092 (MO #98)
    alpha vir-NTO: 0.926531 (MO #101) + -0.331343 (MO #107)
    beta occ-NTO: 0.982779 (MO #99)
    beta vir-NTO: 0.994985 (MO #100)
  Alpha NTO orbitals saved to: output_gpu_charge1/nto_state_1_alpha.molden
  Beta NTO orbitals saved to: output_gpu_charge1/nto_state_1_beta.molden

State 2 (1.183 eV):
State 2: 1.18317 eV  NTO largest component 0.9393709041733694
    alpha occ-NTO: 0.998439 (MO #99)
    alpha vir-NTO: 0.927006 (MO #101) + -0.330368 (MO #107)
    beta occ-NTO: 0.982775 (MO #98)
    beta vir-NTO: 0.994978 (MO #100)
  Alpha NTO orbitals saved to: output_gpu_charge1/nto_state_2_alpha.molden
  Beta NTO orbitals saved to: output_gpu_charge1/nto_state_2_beta.molden

State 3 (1.432 eV):
State 3: 1.43209 eV  NTO largest component 0.9559637347078229
    alpha occ-NTO: 0.999551 (MO #100)
    alpha vir-NTO: 0.999723 (MO #101)
    beta occ-NTO: 0.617651 (MO #96) + 0.785581 (MO #97)
    beta vir-NTO: 0.997106 (MO #100)
  Alpha NTO orbitals saved to: output_gpu_charge1/nto_state_3_alpha.molden
  Beta NTO orbitals saved to: output_gpu_charge1/nto_state_3_beta.molden
======================================================================

======================================================================
TRANSITION CONTRIBUTION ANALYSIS
======================================================================
Analyzing orbital pair contributions to excited states...

======================================================================
STATE 1: 1.1794 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
----------------------------------------------------------------------
Total weight analyzed: 0.000000

======================================================================
STATE 2: 1.1832 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
----------------------------------------------------------------------
Total weight analyzed: 0.000000
Traceback (most recent call last):
  File "/home/indranil/Documents/Secondment/test/PTCDA/anion_cal/tdm_calc_accurate_GPU.py", line 775, in <module>
    contributions, total_weight = analyze_transition_contributions(
  File "/home/indranil/Documents/Secondment/test/PTCDA/anion_cal/tdm_calc_accurate_GPU.py", line 669, in analyze_transition_contributions
    occ_label = labels[occ_idx]
IndexError: list index out of range
