Created output directory: output_gpu_charge0

Parallel computation enabled: 12 threads (auto-detected)

======================================================================
MOLECULE SETUP
======================================================================
Loading molecule from: PTCDA_clean.xyz
Basis set: 6-31g
Charge: 0
#INFO: **** input file is /home/indranil/Documents/Secondment/test/PTCDA/anion_cal/tdm_calc_accurate_GPU.py ****
#!/usr/bin/env python
'''
GPU-Accelerated Transition Density Matrix Calculation
Based on official PySCF examples with GPU4PySCF support

Features:
- GPU acceleration for DFT and TDDFT (B3LYP, UKS fully supported)
- Parallel calculation support
- Configurable grid size and box dimensions
- Selective state output
- HOMO/LUMO cube file generation

Requirements:
- pip install gpu4pyscf-cuda12x
- pip install cutensor-cu12 (optional, for 10-20% better performance)
'''

from pyscf import gto, lib
from pyscf.tools import cubegen, molden
from gpu4pyscf import dft
from gpu4pyscf.tdscf import rks as gpu_tdrks, uks as gpu_tduks
import numpy as np
from functools import reduce
import os

# ============================================================================
# CONFIGURATION SECTION - MODIFY THESE SETTINGS
# ============================================================================

# --- Parallel Calculation Settings ---
# Note: GPU handles DFT/TDDFT parallelization automatically
ENABLE_PARALLEL = True  # Enable/disable parallel computation for CPU operations
NUM_THREADS = 0

# --- Molecule Selection ---
USE_XYZ = True
# XYZ_FILE = 'H2O.xyz'  # Path to XYZ file
XYZ_FILE = 'PTCDA_clean.xyz'
BASIS_SET = '6-31g'

# --- Charge and Spin Settings ---
CHARGE = 0
SPIN = None
# Note: Spin is auto-calculated from electron count if set to None
# For charged systems: cation (+1) typically has spin=2 (doublet), anion (-1) has spin=2 (doublet)
# Neutral even-electron systems typically have spin=1 (singlet)

# --- DFT/TDDFT Settings ---
# Note: TDDFT uses the same basis set and XC functional as ground state DFT
XC_FUNCTIONAL = 'b3lyp'
# Common options:
#   'b3lyp'    - B3LYP (hybrid, good general purpose)
#   'pbe0'     - PBE0 (hybrid, good for excited states)
#   'cam-b3lyp' - CAM-B3LYP (range-separated, good for charge transfer)
#   'wb97x-d'  - ωB97X-D (range-separated with dispersion)
#   'pbe'      - PBE (GGA, faster but less accurate)
#   'blyp'     - BLYP (GGA)

NUM_EXCITED_STATES = 10

# --- TDDFT Method Selection ---
USE_TDA = False
# TDA (Tamm-Dancoff Approximation) is recommended for large systems or initial testing
# For charged/open-shell systems, TDDFT automatically uses appropriate method
# Closed-shell (spin=1): Uses RKS/TDDFT or RKS/TDA
# Open-shell (spin>1): Uses UKS/TDDFT or UKS/TDA

# --- Output Selection ---
# STATES_TO_OUTPUT: Which states to generate CUBE FILES for (0-indexed)
# Cube files are large (~150-500 MB per state), so be selective
# Examples:
#   [0, 1, 2] - First three states
#   [0, 4, 9] - States 1, 5, and 10
#   range(5) - First five states
STATES_TO_OUTPUT = [0, 1, 2]

# --- Cube File Generation Options ---
GENERATE_TRANSITION_DENSITY = True
GENERATE_EXCITED_DENSITY = True
GENERATE_DENSITY_DIFFERENCE = True
GENERATE_HOMO_LUMO = True

# --- Grid Settings ---
# Option 1: Use grid resolution (number of points per axis)
USE_GRID_RESOLUTION = False
GRID_RESOLUTION = [80, 80, 80]

# Option 2: Use box dimensions (in Angstrom) - only used if USE_GRID_RESOLUTION = False
BOX_MARGIN = 4.0
GRID_SPACING = 0.2

# --- NTO Analysis ---
# NTO_STATES: Which states to perform NTO ANALYSIS for (0-indexed)
# NTO molden files are small (~5 MB per state), so you can analyze more states
# This is INDEPENDENT of STATES_TO_OUTPUT - you can have different lists
# Example: Generate cube files for [0,1] but NTO analysis for [0,1,2,3,4]
ENABLE_NTO_ANALYSIS = True
NTO_STATES = [0, 1, 2]

# --- Transition Contribution Analysis ---
# Analyze which orbital pairs (i→a) contribute to each excited state
# Shows percentage contribution and generates cube files for dominant pairs
ENABLE_CONTRIBUTION_ANALYSIS = True
CONTRIBUTION_STATES = [0, 1, 2]
CONTRIBUTION_THRESHOLD = 0.01
TOP_N_CONTRIBUTIONS = 10
GENERATE_PAIR_CUBES = True
MAX_PAIRS_PER_STATE = 3
PAIR_CONTRIBUTION_CUTOFF = 0.05

# --- Output Directory ---
OUTPUT_DIR = 'output_gpu_charge0'

# ============================================================================
# END OF CONFIGURATION
# ============================================================================

# ============================================================================
# SETUP AND INITIALIZATION
# ============================================================================

# Create output directory
if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)
    print(f"Created output directory: {OUTPUT_DIR}")

# Setup parallel computation
if ENABLE_PARALLEL:
    if NUM_THREADS > 0:
        lib.num_threads(NUM_THREADS)
        print(f"\nParallel computation enabled: {NUM_THREADS} threads")
    else:
        # Auto-detect number of cores
        import multiprocessing
        num_cores = multiprocessing.cpu_count()
        lib.num_threads(num_cores)
        print(f"\nParallel computation enabled: {num_cores} threads (auto-detected)")
else:
    lib.num_threads(1)
    print("\nParallel computation disabled: using 1 thread")

# ============================================================================
# 1. MOLECULE DEFINITION
# ============================================================================

def create_h2o_molecule():
    """Create H2O test molecule"""
    mol = gto.M(
        atom = '''
        O  0.0000  0.0000  0.1173
        H  0.0000  0.7572 -0.4692
        H  0.0000 -0.7572 -0.4692
        ''',
        basis = BASIS_SET,
        verbose = 4
    )
    return mol

def calculate_spin_multiplicity(n_electrons, charge):
    """
    Calculate spin multiplicity (2S+1) from electron count.
    
    Args:
        n_electrons: Total number of electrons in neutral molecule
        charge: Molecular charge
    
    Returns:
        spin: Spin multiplicity (2S+1)
    """
    # Adjust electron count for charge
    n_elec = n_electrons - charge
    
    # For even number of electrons: singlet (spin=1)
    # For odd number of electrons: doublet (spin=2)
    if n_elec % 2 == 0:
        spin = 1  # Singlet (closed-shell)
    else:
        spin = 2  # Doublet (open-shell)
    
    return spin

def create_molecule_from_xyz(xyz_file, basis, charge=0, spin=None):
    """
    Load molecule from XYZ file with charge and spin.
    
    Args:
        xyz_file: Path to XYZ file
        basis: Basis set
        charge: Molecular charge
        spin: Spin multiplicity (None = auto-calculate)
    """
    # First, create molecule to get electron count
    mol_temp = gto.M(atom=xyz_file, basis=basis, charge=0, spin=0, verbose=0)
    n_electrons = mol_temp.nelectron
    
    # Calculate spin if not provided
    if spin is None:
        spin = calculate_spin_multiplicity(n_electrons, charge)
    
    # Create final molecule with charge and spin
    mol = gto.M(
        atom = xyz_file,
        basis = basis,
        charge = charge,
        spin = spin - 1,  # PySCF uses 2S (number of unpaired electrons), not 2S+1
        verbose = 4
    )
    
    return mol, spin

print("\n" + "="*70)
print("MOLECULE SETUP")
print("="*70)

if USE_XYZ:
    print(f"Loading molecule from: {XYZ_FILE}")
    print(f"Basis set: {BASIS_SET}")
    print(f"Charge: {CHARGE}")
    mol, calculated_spin = create_molecule_from_xyz(XYZ_FILE, BASIS_SET, CHARGE, SPIN)
    actual_spin = calculated_spin
else:
    print("Using H2O test molecule")
    print(f"Basis set: {BASIS_SET}")
    mol = create_h2o_molecule()
    actual_spin = 1  # H2O is singlet

print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity (2S+1): {actual_spin}")
print(f"Number of unpaired electrons (2S): {mol.spin}")

if actual_spin == 1:
    print("System type: Closed-shell (singlet)")
    dft_method = "RKS"
else:
    print(f"System type: Open-shell ({['singlet', 'doublet', 'triplet', 'quartet', 'quintet'][actual_spin-1] if actual_spin <= 5 else f'spin={actual_spin}'})")
    dft_method = "UKS"

print(f"DFT method: {dft_method} (GPU-accelerated)")

# ============================================================================
# 2. GROUND STATE DFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("GROUND STATE DFT CALCULATION")
print("="*70)
print(f"XC functional: {XC_FUNCTIONAL}")
print(f"Basis set: {BASIS_SET}")
print(f"Method: {dft_method} (GPU-accelerated)")

# Select RKS (closed-shell) or UKS (open-shell) based on spin
if actual_spin == 1:
    mf = dft.RKS(mol)
else:
    mf = dft.UKS(mol)

mf.xc = XC_FUNCTIONAL
mf.kernel()

if not mf.converged:
    print("WARNING: SCF did not converge!")
    print("Try: 1) Different initial guess, 2) Level shifting, 3) DIIS settings")
else:
    print("✓ SCF converged")

print(f"Ground state energy: {mf.e_tot:.6f} a.u.")

# ============================================================================
# 3. TDDFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("TDDFT CALCULATION")
print("="*70)
print(f"Note: TDDFT inherits XC functional ({XC_FUNCTIONAL}) and basis set ({BASIS_SET}) from ground state")
method_name = 'TDA' if USE_TDA else 'TDDFT'
spin_type = 'RKS' if actual_spin == 1 else 'UKS'
print(f"TDDFT method: {method_name} ({spin_type}-based, GPU-accelerated)")

# Select TDA or full TDDFT
# Use gpu4pyscf.tdscf module (RKS or UKS based on spin)
if actual_spin == 1:
    # Closed-shell: use gpu4pyscf.tdscf.rks
    if USE_TDA:
        td = gpu_tdrks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tdrks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
else:
    # Open-shell: use gpu4pyscf.tdscf.uks
    if USE_TDA:
        td = gpu_tduks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tduks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
td.nstates = NUM_EXCITED_STATES
print(f"Calculating {NUM_EXCITED_STATES} excited states...")
td.kernel()

# Handle both RKS (scalar) and UKS (array) convergence
if hasattr(td.converged, '__len__'):  # UKS: array
    if not td.converged.all():
        print(f"WARNING: TDDFT did not converge for some states!")
        print(f"  Converged states: {td.converged.sum()}/{len(td.converged)}")
    else:
        print("✓ TDDFT converged (all states)")
else:  # RKS: scalar
    if not td.converged:
        print("WARNING: TDDFT did not converge!")
    else:
        print("✓ TDDFT converged")

td.analyze()  # Print detailed analysis

# Print excitation energies
print("\n" + "="*70)
print("EXCITED STATE ENERGIES")
print("="*70)
for i, energy in enumerate(td.e):
    print(f"State {i+1}: {energy:.6f} a.u. = {energy*27.211:.3f} eV")
print("="*70)

# ============================================================================
# 4. TRANSITION DIPOLE MOMENTS
# ============================================================================

print("\n" + "="*70)
print("TRANSITION DIPOLE MOMENTS")
print("="*70)

# Set gauge origin to nuclear charge center
charges = mol.atom_charges()
coords = mol.atom_coords()  # in a.u.
nuc_charge_center = np.einsum('z,zx->x', charges, coords) / charges.sum()
mol.set_common_orig_(nuc_charge_center)

# Calculate dipole integrals
dip_ints = mol.intor('cint1e_r_sph', comp=3)  # x, y, z components

def calculate_transition_dipole(td, state_id):
    """
    Calculate transition dipole moment for a given excited state.
    Based on PySCF example: examples/1-advanced/030-transition_dipole.py
    
    Handles both RKS (closed-shell) and UKS (open-shell) cases.
    For GPU4PySCF, converts CuPy arrays to NumPy arrays.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    tdm : ndarray, shape (3,)
        Transition dipole moment [x, y, z] in a.u.
    """
    # Get TDDFT amplitudes (X and Y vectors)
    X, Y = td.xy[state_id]
    
    # Get MO coefficients and occupations
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    
    # Check if UKS by checking if X is a tuple (more reliable than mo_coeff)
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS: mo_coeff and mo_occ are tuples (alpha, beta)
        # For UKS, X and Y are also tuples: ((Xa, Xb), (Ya, Yb))
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        # Xa and Xb are already separated, just need to get dimensions
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Transition density matrices for alpha and beta
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        # Total transition density (alpha + beta)
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
        
    else:
        # RKS: mo_coeff and mo_occ are arrays
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        # Transition density in MO basis
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        
        # Transform to AO basis
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    # Calculate transition dipole: μ = Tr(μ_op * T)
    tdm = np.einsum('xij,ji->x', dip_ints, t_dm1_ao)
    
    return tdm

# Calculate and print transition dipoles for all states
print("\nTransition dipole moments (a.u.):")
print(f"{'State':<8} {'μ_x':<12} {'μ_y':<12} {'μ_z':<12} {'|μ|':<12} {'f':<12}")
print("-" * 70)

for i in range(td.nstates):
    tdm = calculate_transition_dipole(td, i)
    tdm_magnitude = np.linalg.norm(tdm)
    
    # Oscillator strength: f = (2/3) * ω * |μ|^2
    # where ω is excitation energy in a.u.
    omega = td.e[i]
    osc_strength = (2.0/3.0) * omega * tdm_magnitude**2
    
    print(f"{i+1:<8} {tdm[0]:>11.6f} {tdm[1]:>11.6f} {tdm[2]:>11.6f} "
          f"{tdm_magnitude:>11.6f} {osc_strength:>11.6f}")

print("="*70)

# ============================================================================
# 5. TRANSITION DENSITY MATRICES
# ============================================================================

def calculate_transition_density_matrix(td, state_id):
    """
    Calculate transition density matrix between ground and excited state.
    This is the proper transition density for visualization.
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    t_dm1_ao : ndarray
        Transition density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Alpha
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_mo_a[nocc_a:, :nocc_a] = (Xa + Ya).T
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        # Beta
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_mo_b[nocc_b:, :nocc_b] = (Xb + Yb).T
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
    else:
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        t_dm1_mo[nocc:, :nocc] = (X + Y).reshape(nocc, nvir).T
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    return t_dm1_ao

def calculate_excited_state_density(td, state_id):
    """
    Calculate excited state density matrix.
    Based on PySCF examples/tddft/22-density.py
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    dm_excited : ndarray
        Excited state density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mf = td._scf
    mo_coeff = mf.mo_coeff
    mo_occ = mf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS case - simplified approach: use transition density
        # For visualization, transition density is more meaningful
        return calculate_transition_density_matrix(td, state_id)
    else:
        # RKS case
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        nocc = X.shape[0]
        
        # Density matrix changes in MO basis
        dm_oo = -np.einsum('ia,ka->ik', X.conj(), X)
        dm_oo -= np.einsum('ia,ka->ik', Y.conj(), Y)
        
        dm_vv = np.einsum('ia,ic->ac', X, X.conj())
        dm_vv += np.einsum('ia,ic->ac', Y, Y.conj())
        
        # Start with ground state density in MO basis
        dm = np.diag(mo_occ)
        
        # Add TDDFT contribution
        dm[:nocc, :nocc] += dm_oo * 2
        dm[nocc:, nocc:] += dm_vv * 2
        
        # Transform to AO basis
        dm_excited = np.einsum('pi,ij,qj->pq', mo_coeff, dm, mo_coeff.conj())
    
    return dm_excited

# ============================================================================
# 5A. TRANSITION CONTRIBUTION ANALYSIS FUNCTIONS
# ============================================================================

def get_orbital_labels(mf):
    """Get orbital labels (HOMO-n, LUMO+n) for RKS and UKS."""
    mo_occ = mf.mo_occ
    mo_coeff = mf.mo_coeff
    
    # Handle UKS (use alpha spin) and CuPy arrays
    if isinstance(mo_occ, tuple):
        mo_occ = mo_occ[0]
    if isinstance(mo_coeff, tuple):
        mo_coeff = mo_coeff[0]
    if hasattr(mo_occ, 'get'):
        mo_occ = mo_occ.get()
    if hasattr(mo_coeff, 'get'):
        mo_coeff = mo_coeff.get()
    
    # Get number of orbitals from mo_coeff shape
    nmo = mo_coeff.shape[1]
    homo_idx = np.where(mo_occ > 0)[0][-1]
    
    labels = []
    for i in range(nmo):
        if i <= homo_idx:
            offset = homo_idx - i
            labels.append('HOMO' if offset == 0 else f'HOMO-{offset}')
        else:
            offset = i - homo_idx - 1
            labels.append('LUMO' if offset == 0 else f'LUMO+{offset}')
    
    return labels, homo_idx

def analyze_transition_contributions(td, state_id, mf, threshold=0.01, top_n=10):
    """
    Analyze orbital pair contributions to a specific excited state.
    Handles both RKS and UKS systems, and CuPy arrays.
    
    Returns:
        contributions: list of (occ_idx, vir_idx, weight, label) sorted by weight
        total_weight: sum of all weights
    """
    X, Y = td.xy[state_id]
    
    # Handle UKS: X and Y are tuples (Xa, Xb), (Ya, Yb)
    # For simplicity, analyze alpha spin (dominant for most cases)
    if isinstance(X, tuple):
        X, _ = X
        Y, _ = Y
    
    # Convert CuPy to NumPy if needed
    if hasattr(X, 'get'):
        X = X.get()
    if hasattr(Y, 'get'):
        Y = Y.get()
    
    nocc, nvir = X.shape
    
    # For full TDDFT, the contribution is from (X + Y)
    amplitudes = X + Y
    
    # Calculate weights (squared amplitudes)
    weights = amplitudes ** 2
    
    # Get orbital labels
    labels, homo_idx = get_orbital_labels(mf)
    
    # Collect all contributions
    contributions = []
    for i in range(nocc):
        for a in range(nvir):
            weight = weights[i, a]
            if weight > threshold:
                occ_idx = i
                vir_idx = nocc + a
                occ_label = labels[occ_idx]
                vir_label = labels[vir_idx]
                transition_label = f"{occ_label} → {vir_label}"
                contributions.append((occ_idx, vir_idx, weight, transition_label))
    
    # Sort by weight (descending)
    contributions.sort(key=lambda x: x[2], reverse=True)
    
    # Normalize weights to sum to 1
    total_weight = sum(c[2] for c in contributions)
    if total_weight > 0:
        contributions = [(occ, vir, w/total_weight, label) 
                         for occ, vir, w, label in contributions]
    
    # Return top N
    return contributions[:top_n], total_weight

def calculate_pair_transition_density(mf, occ_idx, vir_idx):
    """
    Calculate transition density matrix for a single orbital pair i→a.
    Handles both RKS and UKS (uses alpha spin for UKS), and CuPy arrays.
    
    T_μν = C_μ^i × C_ν^a + C_μ^a × C_ν^i
    """
    mo_coeff = mf.mo_coeff
    
    # Handle UKS (use alpha spin)
    if isinstance(mo_coeff, tuple):
        mo_coeff = mo_coeff[0]
    
    # Convert CuPy to NumPy if needed
    if hasattr(mo_coeff, 'get'):
        mo_coeff = mo_coeff.get()
    
    occ_mo = mo_coeff[:, occ_idx]
    vir_mo = mo_coeff[:, vir_idx]
    
    # Transition density matrix for this pair
    t_dm = np.outer(occ_mo, vir_mo) + np.outer(vir_mo, occ_mo)
    
    return t_dm

# ============================================================================
# 6. NATURAL TRANSITION ORBITALS (NTO) ANALYSIS
# ============================================================================

if ENABLE_NTO_ANALYSIS:
    print("\n" + "="*70)
    print("NATURAL TRANSITION ORBITAL ANALYSIS")
    print("="*70)
    
    # Filter valid NTO states
    valid_nto_states = [s for s in NTO_STATES if s < td.nstates]
    
    if not valid_nto_states:
        print("No valid NTO states selected.")
    else:
        for i in valid_nto_states:
            print(f"\nState {i+1} ({td.e[i]*27.211:.3f} eV):")
            weights, nto_coeff = td.get_nto(state=i+1, verbose=4)
            
            # Save NTO orbitals to molden format for visualization
            # For UKS, nto_coeff is a tuple (alpha, beta)
            if isinstance(nto_coeff, tuple):
                # Save alpha NTOs
                molden_file_a = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_alpha.molden')
                molden.from_mo(mol, molden_file_a, nto_coeff[0])
                print(f"  Alpha NTO orbitals saved to: {molden_file_a}")
                
                # Save beta NTOs
                molden_file_b = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_beta.molden')
                molden.from_mo(mol, molden_file_b, nto_coeff[1])
                print(f"  Beta NTO orbitals saved to: {molden_file_b}")
            else:
                # RKS case
                molden_file = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}.molden')
                molden.from_mo(mol, molden_file, nto_coeff)
                print(f"  NTO orbitals saved to: {molden_file}")
    
    print("="*70)
else:
    print("\nNTO analysis disabled.")

# ============================================================================
# 6A. TRANSITION CONTRIBUTION ANALYSIS
# ============================================================================

if ENABLE_CONTRIBUTION_ANALYSIS:
    print("\n" + "="*70)
    print("TRANSITION CONTRIBUTION ANALYSIS")
    print("="*70)
    print("Analyzing orbital pair contributions to excited states...")
    
    # Filter valid states
    valid_contrib_states = [s for s in CONTRIBUTION_STATES if s < td.nstates]
    
    if not valid_contrib_states:
        print("No valid states selected for contribution analysis.")
    else:
        # Store all contributions for summary
        all_contributions = {}
        
        for state_id in valid_contrib_states:
            excitation_energy = td.e[state_id] * 27.211  # Convert to eV
            
            # Analyze contributions
            contributions, total_weight = analyze_transition_contributions(
                td, state_id, mf,
                threshold=CONTRIBUTION_THRESHOLD,
                top_n=TOP_N_CONTRIBUTIONS
            )
            
            all_contributions[state_id] = (contributions, total_weight)
            
            # Print contribution table
            print(f"\n{'='*70}")
            print(f"STATE {state_id+1}: {excitation_energy:.4f} eV")
            print(f"{'='*70}")
            print(f"{'Rank':<6} {'Transition':<20} {'Weight':<12} {'Percentage':<12} {'Cumulative':<12}")
            print(f"{'-'*70}")
            
            cumulative = 0.0
            for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
                cumulative += weight
                print(f"{rank:<6} {label:<20} {weight:<12.6f} {weight*100:<12.2f}% {cumulative*100:<12.2f}%")
            
            print(f"{'-'*70}")
            print(f"Total weight analyzed: {total_weight:.6f}")
        
        # Save contribution tables to file
        table_file = os.path.join(OUTPUT_DIR, 'contribution_tables.txt')
        with open(table_file, 'w') as f:
            f.write("="*70 + "\n")
            f.write("ORBITAL PAIR CONTRIBUTIONS TO EXCITED STATES\n")
            f.write("="*70 + "\n\n")
            
            for state_id in valid_contrib_states:
                contributions, total_weight = all_contributions[state_id]
                excitation_energy = td.e[state_id] * 27.211
                
                f.write(f"\n{'='*70}\n")
                f.write(f"STATE {state_id+1}: {excitation_energy:.4f} eV\n")
                f.write(f"{'='*70}\n")
                f.write(f"{'Rank':<6} {'Transition':<20} {'Weight':<12} {'Percentage':<12} {'Cumulative':<12}\n")
                f.write(f"{'-'*70}\n")
                
                cumulative = 0.0
                for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
                    cumulative += weight
                    f.write(f"{rank:<6} {label:<20} {weight:<12.6f} {weight*100:<12.2f}% {cumulative*100:<12.2f}%\n")
                
                f.write(f"{'-'*70}\n")
                f.write(f"Total weight analyzed: {total_weight:.6f}\n")
                f.write(f"{'='*70}\n\n")
        
        print(f"\n✓ Contribution tables saved to: {table_file}")
        
        # Generate cube files for dominant orbital pairs
        if GENERATE_PAIR_CUBES:
            print(f"\n{'='*70}")
            print("GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES")
            print(f"{'='*70}")
            print("Note: Cube files will be generated after grid parameters are calculated")
            print("      (see CUBE FILE GENERATION section below)")
    
    print("="*70)
else:
    print("\nTransition contribution analysis disabled.")

# ============================================================================
# 7. CALCULATE GRID PARAMETERS
# ============================================================================

def calculate_grid_parameters(mol, use_resolution=True, resolution=None, 
                             box_margin=4.0, grid_spacing=0.2):
    """
    Calculate grid parameters for cube file generation.
    
    Parameters:
    -----------
    mol : Mole object
    use_resolution : bool
        If True, use fixed resolution. If False, calculate from box dimensions.
    resolution : list [nx, ny, nz]
        Grid resolution (number of points per axis)
    box_margin : float
        Margin around molecule in Angstrom
    grid_spacing : float
        Grid spacing in Angstrom
    
    Returns:
    --------
    nx, ny, nz : int
        Grid resolution
    box_info : dict
        Box dimension information
    """
    # Get molecular coordinates in Angstrom
    coords = mol.atom_coords() * 0.529177  # Bohr to Angstrom
    
    # Calculate bounding box
    min_coords = coords.min(axis=0)
    max_coords = coords.max(axis=0)
    mol_size = max_coords - min_coords
    
    box_info = {
        'min_coords': min_coords,
        'max_coords': max_coords,
        'mol_size': mol_size,
        'box_margin': box_margin
    }
    
    if use_resolution:
        nx, ny, nz = resolution
        actual_spacing = mol_size / np.array([nx, ny, nz])
        box_info['grid_spacing'] = actual_spacing
        box_info['total_points'] = nx * ny * nz
    else:
        # Calculate grid points from spacing and box size
        box_size = mol_size + 2 * box_margin
        nx = int(np.ceil(box_size[0] / grid_spacing))
        ny = int(np.ceil(box_size[1] / grid_spacing))
        nz = int(np.ceil(box_size[2] / grid_spacing))
        box_info['grid_spacing'] = [grid_spacing] * 3
        box_info['box_size'] = box_size
        box_info['total_points'] = nx * ny * nz
    
    return nx, ny, nz, box_info

# Calculate grid parameters
print("\n" + "="*70)
print("GRID PARAMETERS")
print("="*70)

if USE_GRID_RESOLUTION:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=True, resolution=GRID_RESOLUTION
    )
    print(f"Using fixed grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Molecule size: {box_info['mol_size']} Å")
    print(f"Effective grid spacing: {box_info['grid_spacing']} Å")
else:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=False, box_margin=BOX_MARGIN, 
        grid_spacing=GRID_SPACING
    )
    print(f"Using box dimensions with margin: {BOX_MARGIN} Å")
    print(f"Grid spacing: {GRID_SPACING} Å")
    print(f"Calculated grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Box size: {box_info['box_size']} Å")

print("="*70)

# ============================================================================
# 8. GENERATE HOMO/LUMO CUBE FILES
# ============================================================================

if GENERATE_HOMO_LUMO:
    print("\n" + "="*70)
    print("GENERATING HOMO/LUMO CUBE FILES")
    print("="*70)
    
    # Get HOMO and LUMO indices (handle both RKS and UKS)
    if actual_spin == 1:  # RKS (closed-shell)
        mo_occ = mf.mo_occ
        mo_coeff = mf.mo_coeff
        mo_energy = mf.mo_energy
    else:  # UKS (open-shell) - use alpha orbitals
        mo_occ = mf.mo_occ[0]  # Alpha occupation
        mo_coeff = mf.mo_coeff[0]  # Alpha coefficients
        mo_energy = mf.mo_energy[0]  # Alpha energies
        print("Note: Using alpha orbitals for HOMO/LUMO (open-shell system)")
    
    # Convert CuPy to NumPy if needed
    if hasattr(mo_occ, 'get'):
        mo_occ = mo_occ.get()
        mo_coeff = mo_coeff.get()
        mo_energy = mo_energy.get()
    
    homo_idx = np.where(mo_occ > 0)[0][-1]
    lumo_idx = np.where(mo_occ == 0)[0][0]
    
    print(f"HOMO index: {homo_idx}")
    print(f"LUMO index: {lumo_idx}")
    print(f"HOMO energy: {mo_energy[homo_idx]*27.211:.3f} eV")
    print(f"LUMO energy: {mo_energy[lumo_idx]*27.211:.3f} eV")
    print(f"HOMO-LUMO gap: {(mo_energy[lumo_idx] - mo_energy[homo_idx])*27.211:.3f} eV")
    
    # Generate HOMO cube file
    homo_file = os.path.join(OUTPUT_DIR, 'HOMO.cube')
    cubegen.orbital(mol, homo_file, mo_coeff[:, homo_idx], nx=nx, ny=ny, nz=nz)
    print(f"\n  ✓ HOMO orbital: {homo_file}")
    
    # Generate LUMO cube file
    lumo_file = os.path.join(OUTPUT_DIR, 'LUMO.cube')
    cubegen.orbital(mol, lumo_file, mo_coeff[:, lumo_idx], nx=nx, ny=ny, nz=nz)
    print(f"  ✓ LUMO orbital: {lumo_file}")
    
    # Generate HOMO-1 and LUMO+1 for additional verification
    if homo_idx > 0:
        homo1_file = os.path.join(OUTPUT_DIR, 'HOMO-1.cube')
        cubegen.orbital(mol, homo1_file, mo_coeff[:, homo_idx-1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ HOMO-1 orbital: {homo1_file}")
    
    if lumo_idx < len(mo_occ) - 1:
        lumo1_file = os.path.join(OUTPUT_DIR, 'LUMO+1.cube')
        cubegen.orbital(mol, lumo1_file, mo_coeff[:, lumo_idx+1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ LUMO+1 orbital: {lumo1_file}")
    
    print("\nVerification tip:")
    print("For the first excited state (S1), check if the transition density")
    print("resembles a HOMO→LUMO transition by comparing:")
    print("  - transition_density_state1.cube")
    print("  - HOMO.cube (electron depletion)")
    print("  - LUMO.cube (electron accumulation)")
    
    # Analytical verification: Calculate HOMO→LUMO transition density
    print("\n" + "-"*70)
    print("ANALYTICAL VERIFICATION: HOMO→LUMO Transition Density")
    print("-"*70)
    
    # Construct approximate HOMO→LUMO transition density matrix
    homo_mo = mo_coeff[:, homo_idx]
    lumo_mo = mo_coeff[:, lumo_idx]
    
    # T_approx = |HOMO⟩⟨LUMO| + |LUMO⟩⟨HOMO|
    # In AO basis: T_μν = C_μ^HOMO * C_ν^LUMO + C_μ^LUMO * C_ν^HOMO
    t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
    
    # Generate cube file for HOMO→LUMO transition density
    homo_lumo_file = os.path.join(OUTPUT_DIR, 'transition_HOMO_LUMO_analytical.cube')
    cubegen.density(mol, homo_lumo_file, t_homo_lumo, nx=nx, ny=ny, nz=nz)
    print(f"  ✓ Analytical HOMO→LUMO transition: {homo_lumo_file}")
    
    print("\nTo verify S1 is a HOMO→LUMO transition, compare:")
    print(f"  1. {os.path.join(OUTPUT_DIR, 'transition_density_state1.cube')}")
    print(f"  2. {homo_lumo_file}")
    print("\nThey should be very similar if S1 is dominated by HOMO→LUMO excitation.")
    print("You can calculate the overlap/similarity in VMD or by visual inspection.")
    
    print("="*70)
else:
    print("\nHOMO/LUMO generation disabled.")

# ============================================================================
# 9. GENERATE CUBE FILES FOR SELECTED EXCITED STATES
# ============================================================================

print("\n" + "="*70)
print("GENERATING EXCITED STATE CUBE FILES")
print("="*70)

# Filter valid states
valid_states = [s for s in STATES_TO_OUTPUT if s < td.nstates]

if not valid_states:
    print("No valid states selected for cube file generation.")
else:
    print(f"Generating cube files for states: {[s+1 for s in valid_states]}")
    print(f"Grid resolution: {nx} × {ny} × {nz}")
    
    for state_id in valid_states:
        print(f"\nState {state_id+1}: {td.e[state_id]*27.211:.3f} eV")
        
        # 1. Transition density matrix
        if GENERATE_TRANSITION_DENSITY:
            dm_trans = calculate_transition_density_matrix(td, state_id)
            filename_trans = os.path.join(OUTPUT_DIR, f'transition_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_trans, dm_trans, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Transition density: {filename_trans}")
        
        # 2. Excited state density
        if GENERATE_EXCITED_DENSITY:
            dm_excited = calculate_excited_state_density(td, state_id)
            filename_excited = os.path.join(OUTPUT_DIR, f'excited_state_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_excited, dm_excited, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Excited state density: {filename_excited}")
        
        # 3. Density difference
        if GENERATE_DENSITY_DIFFERENCE:
            if not GENERATE_EXCITED_DENSITY:
                dm_excited = calculate_excited_state_density(td, state_id)
            
            # Get ground state density and convert CuPy to NumPy if needed
            dm_ground = mf.make_rdm1()
            if hasattr(dm_ground, 'get'):
                dm_ground = dm_ground.get()
            
            # For UKS, dm_ground is a tuple (alpha, beta), sum them
            if isinstance(dm_ground, tuple):
                dm_ground = dm_ground[0] + dm_ground[1]
            
            dm_diff = dm_excited - dm_ground
            filename_diff = os.path.join(OUTPUT_DIR, f'density_difference_state{state_id+1}.cube')
            cubegen.density(mol, filename_diff, dm_diff, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Density difference: {filename_diff}")
        
        # Quantitative verification for first state
        if state_id == 0 and GENERATE_HOMO_LUMO and GENERATE_TRANSITION_DENSITY:
            print("\n  " + "-"*66)
            print("  QUANTITATIVE VERIFICATION: S1 vs HOMO→LUMO")
            print("  " + "-"*66)
            
            # Get HOMO and LUMO indices (handle both RKS and UKS)
            if actual_spin == 1:
                mo_occ_ver = mf.mo_occ
                mo_coeff_ver = mf.mo_coeff
            else:
                mo_occ_ver = mf.mo_occ[0]
                mo_coeff_ver = mf.mo_coeff[0]
            
            # Convert CuPy to NumPy if needed
            if hasattr(mo_occ_ver, 'get'):
                mo_occ_ver = mo_occ_ver.get()
                mo_coeff_ver = mo_coeff_ver.get()
            
            homo_idx = np.where(mo_occ_ver > 0)[0][-1]
            lumo_idx = np.where(mo_occ_ver == 0)[0][0]
            
            # Calculate analytical HOMO→LUMO transition density
            homo_mo = mo_coeff_ver[:, homo_idx]
            lumo_mo = mo_coeff_ver[:, lumo_idx]
            t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
            
            # Get TDDFT transition density for S1
            dm_trans_s1 = calculate_transition_density_matrix(td, 0)
            
            # Calculate overlap/similarity (Frobenius inner product)
            overlap = np.sum(dm_trans_s1 * t_homo_lumo)
            norm_tddft = np.linalg.norm(dm_trans_s1)
            norm_homo_lumo = np.linalg.norm(t_homo_lumo)
            similarity = overlap / (norm_tddft * norm_homo_lumo)
            
            # Calculate HOMO→LUMO contribution from TDDFT amplitudes
            X, Y = td.xy[0]
            
            # For UKS, X and Y are tuples (Xa, Xb), (Ya, Yb)
            if actual_spin > 1:
                Xa, Xb = X
                Ya, Yb = Y
                # Convert CuPy to NumPy if needed
                if hasattr(Xa, 'get'):
                    Xa = Xa.get()
                    Ya = Ya.get()
                # Use only alpha part for verification
                # HOMO is last occupied (nocc_a-1), LUMO is first virtual (0)
                homo_lumo_amplitude = abs(Xa[-1, 0] + Ya[-1, 0])
                total_amplitude = np.linalg.norm(Xa + Ya)
            else:
                # Convert CuPy to NumPy if needed
                if hasattr(X, 'get'):
                    X = X.get()
                    Y = Y.get()
                nocc = X.shape[0]
                nvir = X.shape[1]
                # HOMO is index nocc-1 in occupied space, LUMO is index 0 in virtual space
                homo_lumo_amplitude = abs(X[nocc-1, 0] + Y[nocc-1, 0])
                total_amplitude = np.linalg.norm(X + Y)
            
            homo_lumo_weight = (homo_lumo_amplitude / total_amplitude)**2
            
            print(f"  Similarity (cosine): {similarity:.4f}")
            print(f"  HOMO→LUMO weight: {homo_lumo_weight:.4f} ({homo_lumo_weight*100:.1f}%)")
            print(f"  HOMO→LUMO amplitude: {homo_lumo_amplitude:.4f}")
            
            if similarity > 0.95 and homo_lumo_weight > 0.8:
                print("  ✓ S1 is STRONGLY dominated by HOMO→LUMO transition")
            elif similarity > 0.85 and homo_lumo_weight > 0.6:
                print("  ✓ S1 is MOSTLY a HOMO→LUMO transition")
            elif similarity > 0.70 and homo_lumo_weight > 0.4:
                print("  ⚠ S1 has SIGNIFICANT HOMO→LUMO character but mixed")
            else:
                print("  ⚠ S1 is NOT a pure HOMO→LUMO transition (multi-configurational)")
            
            print("  " + "-"*66)

print("="*70)

# ============================================================================
# 9A. GENERATE ORBITAL PAIR TRANSITION DENSITY CUBE FILES
# ============================================================================

if ENABLE_CONTRIBUTION_ANALYSIS and GENERATE_PAIR_CUBES and 'all_contributions' in locals():
    print("\n" + "="*70)
    print("GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES")
    print("="*70)
    
    for state_id in valid_contrib_states:
        if state_id not in all_contributions:
            continue
        
        contributions, _ = all_contributions[state_id]
        excitation_energy = td.e[state_id] * 27.211
        
        print(f"\nState {state_id+1} ({excitation_energy:.4f} eV):")
        
        pair_count = 0
        for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
            if pair_count >= MAX_PAIRS_PER_STATE:
                break
            
            if weight < PAIR_CONTRIBUTION_CUTOFF:
                print(f"  Skipping {label} (contribution {weight*100:.2f}% < {PAIR_CONTRIBUTION_CUTOFF*100:.0f}%)")
                continue
            
            # Calculate transition density for this pair
            t_dm_pair = calculate_pair_transition_density(mf, occ_idx, vir_idx)
            
            # Generate cube file
            labels, _ = get_orbital_labels(mf)
            occ_label = labels[occ_idx].replace('-', 'm').replace('+', 'p')
            vir_label = labels[vir_idx].replace('-', 'm').replace('+', 'p')
            
            filename = os.path.join(OUTPUT_DIR, 
                f'transition_pair_state{state_id+1}_{occ_label}_to_{vir_label}.cube')
            
            cubegen.density(mol, filename, t_dm_pair, nx=nx, ny=ny, nz=nz)
            
            print(f"  ✓ Rank {rank}: {label} ({weight*100:.2f}%) → {filename}")
            pair_count += 1
    
    print("="*70)

# ============================================================================
# 10. CALCULATION SUMMARY
# ============================================================================

print("\n" + "="*70)
print("CALCULATION SUMMARY")
print("="*70)

print(f"\nMolecule: {'XYZ file: ' + XYZ_FILE if USE_XYZ else 'H2O test molecule'}")
print(f"Basis set: {BASIS_SET}")
print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity: {actual_spin} ({'closed-shell' if actual_spin == 1 else 'open-shell'})")

print(f"\nComputational settings:")
print(f"  DFT method: {dft_method}")
print(f"  XC functional: {XC_FUNCTIONAL}")
print(f"  Parallel threads: {NUM_THREADS if NUM_THREADS > 0 else 'auto-detected'}")
print(f"  TDDFT method: Full TDDFT (not TDA)")
print(f"  Number of excited states calculated: {NUM_EXCITED_STATES}")

print(f"\nGrid settings:")
if USE_GRID_RESOLUTION:
    print(f"  Mode: Fixed resolution")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")
else:
    print(f"  Mode: Box dimensions")
    print(f"  Margin: {BOX_MARGIN} Å, Spacing: {GRID_SPACING} Å")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")

print(f"\nOutput files generated:")
if GENERATE_HOMO_LUMO:
    print(f"  ✓ HOMO/LUMO orbitals (in {OUTPUT_DIR}/)")
if ENABLE_NTO_ANALYSIS and valid_nto_states:
    print(f"  ✓ NTO analysis for {len(valid_nto_states)} state(s)")
if valid_states:
    print(f"  ✓ Cube files for {len(valid_states)} state(s):")
    if GENERATE_TRANSITION_DENSITY:
        print(f"    - Transition density matrices")
    if GENERATE_EXCITED_DENSITY:
        print(f"    - Excited state densities")
    if GENERATE_DENSITY_DIFFERENCE:
        print(f"    - Density differences")

print(f"\nAll output files saved to: {OUTPUT_DIR}/")

print("\n" + "="*70)
print("VISUALIZATION GUIDE")
print("="*70)
print("""
Three types of cube files generated:

1. transition_density_state*.cube
   - Represents the electronic transition between ground and excited state
   - Used for calculating transition dipole moments
   - Visualize with isovalues ±0.002

2. excited_state_density_state*.cube
   - Total electron density in the excited state
   - Compare with ground state density

3. density_difference_state*.cube
   - Change in electron density (excited - ground)
   - Red/positive: electron accumulation
   - Blue/negative: electron depletion
   - Recommended for visualization

VMD visualization:
  vmd output/density_difference_state1.cube
  Graphics > Representations > Drawing Method: Isosurface
  - Rep 1: Isovalue = +0.002, Color = Red (electron gain)
  - Rep 2: Isovalue = -0.002, Color = Blue (electron loss)

Jmol visualization:
  isosurface ID "surf1" cutoff  0.002 output/density_difference_state1.cube
  isosurface ID "surf2" cutoff -0.002 output/density_difference_state1.cube

HOMO/LUMO verification:
  Compare transition_density_state1.cube with HOMO.cube and LUMO.cube
  to verify that S1 corresponds to a HOMO→LUMO transition.

NTO visualization:
  Open output/nto_state_*.molden files in Jmol, Avogadro, or VMD
""")
print("="*70)

print("\n✓ Calculation completed successfully!")
print(f"✓ All files saved to: {OUTPUT_DIR}/\n")
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='DesktopGTX3060', release='5.15.0-161-generic', version='#171-Ubuntu SMP Sat Oct 11 08:17:01 UTC 2025', machine='x86_64')  Threads 12
Python 3.10.12 (main, Aug 15 2025, 14:32:43) [GCC 11.4.0]
numpy 1.26.4  scipy 1.11.4  h5py 3.15.1
Date: Tue Nov 18 14:51:10 2025
PySCF version 2.11.0
PySCF path  /home/indranil/.local/lib/python3.10/site-packages/pyscf/__init__.py
CUDA Environment
    CuPy 13.4.1
    CUDA Path /usr
    CUDA Build Version 12080
    CUDA Driver Version 12090
    CUDA Runtime Version 12080
CUDA toolkit
    cuSolver (11, 7, 4)
    cuBLAS 120900
    cuTENSOR 20301
Device info
    Device name b'NVIDIA GeForce RTX 3060'
    Device global memory 11.63 GB
    CuPy memory fraction 0.9
    Num. Devices 1
GPU4PySCF 1.4.3
GPU4PySCF path  /home/indranil/.local/lib/python3.10/site-packages/gpu4pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 38
[INPUT] num. electrons = 200
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 C      2.896522000000   0.014575000000   0.000000000000 AA    5.473633293777   0.027542758266   0.000000000000 Bohr   0.0
[INPUT]  2 C     -3.625534000000  -1.241935000000   0.000000000000 AA   -6.851266315299  -2.346917014512   0.000000000000 Bohr   0.0
[INPUT]  3 C      1.437634000000   0.009164000000   0.000000000000 AA    2.716734527363   0.017317450206   0.000000000000 Bohr   0.0
[INPUT]  4 C     -2.895730000000  -0.014912000000   0.000000000000 AA   -5.472136630687  -0.028179595970   0.000000000000 Bohr   0.0
[INPUT]  5 C      0.729281000000  -1.249862000000   0.000000000000 AA    1.378141357849  -2.361896873501   0.000000000000 Bohr   0.0
[INPUT]  6 C     -0.727755000000  -1.261619000000   0.000000000000 AA   -1.375257635783  -2.384114383548   0.000000000000 Bohr   0.0
[INPUT]  7 C     -1.436957000000  -0.009874000000   0.000000000000 AA   -2.715455182777  -0.018659155754   0.000000000000 Bohr   0.0
[INPUT]  8 C      3.626674000000   1.242670000000   0.000000000000 AA    6.853420603081   2.348305963213   0.000000000000 Bohr   0.0
[INPUT]  9 C      0.728503000000   1.260811000000   0.000000000000 AA    1.376671150924   2.382587484839   0.000000000000 Bohr   0.0
[INPUT] 10 C     -5.092425000000  -1.228040000000   0.000000000000 AA   -9.623288559888  -2.320659270011   0.000000000000 Bohr   0.0
[INPUT] 11 C     -0.728118000000   1.249065000000   0.000000000000 AA   -1.375943606366   2.360390761780   0.000000000000 Bohr   0.0
[INPUT] 12 C     -5.057623000000   1.241537000000   0.000000000000 AA   -9.557522311301   2.346164903514   0.000000000000 Bohr   0.0
[INPUT] 13 C     -2.901906000000  -2.476606000000   0.000000000000 AA   -5.483807579232  -4.680107058455   0.000000000000 Bohr   0.0
[INPUT] 14 C      3.601221000000  -1.226169000000   0.000000000000 AA    6.805321404032  -2.317123592432   0.000000000000 Bohr   0.0
[INPUT] 15 C      1.487021000000  -2.470749000000   0.000000000000 AA    2.810062431477  -4.669038932543   0.000000000000 Bohr   0.0
[INPUT] 16 C      2.901581000000   2.477708000000   0.000000000000 AA    5.483193418242   4.682189536644   0.000000000000 Bohr   0.0
[INPUT] 17 C      5.092590000000   1.230486000000   0.000000000000 AA    9.623600364699   2.325281540112   0.000000000000 Bohr   0.0
[INPUT] 18 C     -1.492998000000  -2.485108000000   0.000000000000 AA   -2.821357324523  -4.696173509966   0.000000000000 Bohr   0.0
[INPUT] 19 C      5.056187000000  -1.242165000000   0.000000000000 AA    9.554808664586  -2.347351651520   0.000000000000 Bohr   0.0
[INPUT] 20 C      1.493062000000   2.485432000000   0.000000000000 AA    2.821478266995   4.696785781230   0.000000000000 Bohr   0.0
[INPUT] 21 C     -3.601702000000   1.225997000000   0.000000000000 AA   -6.806230362298   2.316798559538   0.000000000000 Bohr   0.0
[INPUT] 22 C      2.893134000000  -2.460012000000   0.000000000000 AA    5.467230901667  -4.648748943144   0.000000000000 Bohr   0.0
[INPUT] 23 C     -1.485604000000   2.469918000000   0.000000000000 AA   -2.807384689558   4.667468570133   0.000000000000 Bohr   0.0
[INPUT] 24 C     -2.893236000000   2.458717000000   0.000000000000 AA   -5.467423653732   4.646301747812   0.000000000000 Bohr   0.0
[INPUT] 25 O     -5.732320000000   0.026109000000   0.000000000000 AA  -10.832514858367   0.049338859386   0.000000000000 Bohr   0.0
[INPUT] 26 O      5.734140000000  -0.025581000000   0.000000000000 AA   10.835954159914  -0.048341083992   0.000000000000 Bohr   0.0
[INPUT] 27 O     -5.767539000000   2.259992000000   0.000000000000 AA  -10.899069122748   4.270765923708   0.000000000000 Bohr   0.0
[INPUT] 28 O     -5.856852000000  -2.197455000000   0.000000000000 AA  -11.067846232111  -4.152588121056   0.000000000000 Bohr   0.0
[INPUT] 29 O      5.766769000000  -2.260350000000   0.000000000000 AA   10.897614033632  -4.271442445661   0.000000000000 Bohr   0.0
[INPUT] 30 O      5.853157000000   2.198203000000   0.000000000000 AA   11.060863694081   4.154001636197   0.000000000000 Bohr   0.0
[INPUT] 31 H      0.966973000000  -3.439928000000   0.000000000000 AA    1.827314139849  -6.500521808223   0.000000000000 Bohr   0.0
[INPUT] 32 H     -3.465927000000  -3.425329000000   0.000000000000 AA   -6.549652797735  -6.472933696530   0.000000000000 Bohr   0.0
[INPUT] 33 H     -0.969686000000  -3.454698000000   0.000000000000 AA   -1.832440966825  -6.528433063083   0.000000000000 Bohr   0.0
[INPUT] 34 H      0.969067000000   3.454476000000   0.000000000000 AA    1.831271226354   6.528013543883   0.000000000000 Bohr   0.0
[INPUT] 35 H      3.465022000000   3.426681000000   0.000000000000 AA    6.547942595593   6.475488606251   0.000000000000 Bohr   0.0
[INPUT] 36 H      3.481146000000  -3.397659000000   0.000000000000 AA    6.578412539625  -6.420644974664   0.000000000000 Bohr   0.0
[INPUT] 37 H     -0.966845000000   3.439743000000   0.000000000000 AA   -1.827072254905   6.500172208890   0.000000000000 Bohr   0.0
[INPUT] 38 H     -3.480925000000   3.396767000000   0.000000000000 AA   -6.577994910152   6.418959338960   0.000000000000 Bohr   0.0

nuclear repulsion = 2584.1133492772
number of shells = 166
number of NR pGTOs = 692
number of NR cGTOs = 286
basis = 6-31g
ecp = {}
CPU time:         2.41
Number of atoms: 38
Number of electrons: 200
Number of basis functions: 286
Molecular charge: 0
Spin multiplicity (2S+1): 1
Number of unpaired electrons (2S): 0
System type: Closed-shell (singlet)
DFT method: RKS (GPU-accelerated)

======================================================================
GROUND STATE DFT CALCULATION
======================================================================
XC functional: b3lyp
Basis set: 6-31g
Method: RKS (GPU-accelerated)


******** <class 'gpu4pyscf.dft.rks.RKS'> ********
method = RKS
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'gpu4pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
diis_damp = 0
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
max_memory 4000 MB (current use 471 MB)
XC library gpu4pyscf.dft.libxc version 7.0.0 (CUDA)
    unable to decode the reference due to https://github.com/NVIDIA/cuda-python/issues/29
XC functionals = b3lyp
radial grids: 
    Treutler-Ahlrichs [JCP 102, 346 (1995); DOI:10.1063/1.469408] (M4) radial grids
    
becke partition: Becke, JCP 88, 2547 (1988); DOI:10.1063/1.454033
pruning grids: <function nwchem_prune at 0x7f7f0312d6c0>
grids dens level: 3
symmetrized grids: False
atomic radii adjust function: <function treutler_atomic_radii_adjust at 0x7f7f0312d510>
small_rho_cutoff = 1e-07
Set gradient conv threshold to 3.16228e-05
tot grids = 502016
init E= -1376.30160304486
  HOMO = -0.253323503118697  LUMO = -0.19762094548326
cycle= 1 E= -1369.61520750651  delta_E= 6.69  |g|= 1.88  |ddm|= 7.88
  HOMO = -0.133037289631217  LUMO = -0.117301603630207
cycle= 2 E= -1361.39644562547  delta_E= 8.22  |g|= 5.54  |ddm|= 9.35
  HOMO = -0.203113791583729  LUMO = -0.137613308378187
cycle= 3 E= -1369.94777357805  delta_E= -8.55  |g|= 1.22  |ddm|= 8.44
  HOMO = -0.236236297271634  LUMO = -0.163979026444164
cycle= 4 E= -1370.37865113071  delta_E= -0.431  |g|= 0.318  |ddm|= 1.82
  HOMO = -0.251210140306563  LUMO = -0.170423324047593
cycle= 5 E= -1370.36955713733  delta_E= 0.00909  |g|= 0.354  |ddm|= 0.938
  HOMO = -0.247997423944264  LUMO = -0.168130925758908
cycle= 6 E= -1370.4061763036  delta_E= -0.0366  |g|= 0.066  |ddm|= 0.54
  HOMO = -0.243820162297467  LUMO = -0.163529178878442
cycle= 7 E= -1370.4072514243  delta_E= -0.00108  |g|= 0.0273  |ddm|= 0.108
  HOMO = -0.244042068847704  LUMO = -0.163425580860358
cycle= 8 E= -1370.40739637911  delta_E= -0.000145  |g|= 0.00784  |ddm|= 0.0372
  HOMO = -0.244075631586213  LUMO = -0.163416474215206
cycle= 9 E= -1370.40741117574  delta_E= -1.48e-05  |g|= 0.00337  |ddm|= 0.0136
  HOMO = -0.244133283937176  LUMO = -0.163456333760672
cycle= 10 E= -1370.40741260151  delta_E= -1.43e-06  |g|= 0.00209  |ddm|= 0.005
  HOMO = -0.244081926135315  LUMO = -0.163391966093369
cycle= 11 E= -1370.4074134924  delta_E= -8.91e-07  |g|= 0.00102  |ddm|= 0.00371
  HOMO = -0.244044173695674  LUMO = -0.163342145165032
cycle= 12 E= -1370.40741367525  delta_E= -1.83e-07  |g|= 0.000461  |ddm|= 0.0019
  HOMO = -0.244065180279506  LUMO = -0.1633658344392
cycle= 13 E= -1370.40741373229  delta_E= -5.7e-08  |g|= 0.000101  |ddm|= 0.000889
  HOMO = -0.24406550751989  LUMO = -0.163366267480036
cycle= 14 E= -1370.40741373505  delta_E= -2.76e-09  |g|= 2.8e-05  |ddm|= 0.000157
  HOMO = -0.244066924875194  LUMO = -0.163367069319576
cycle= 15 E= -1370.4074137349  delta_E= 1.55e-10  |g|= 3.58e-05  |ddm|= 8.35e-05
  HOMO = -0.244066482564157  LUMO = -0.163366725219485
cycle= 16 E= -1370.40741373523  delta_E= -3.35e-10  |g|= 3.37e-06  |ddm|= 5.14e-05
converged SCF energy = -1370.40741373523
✓ SCF converged
Ground state energy: -1370.407414 a.u.

======================================================================
TDDFT CALCULATION
======================================================================
Note: TDDFT inherits XC functional (b3lyp) and basis set (6-31g) from ground state
TDDFT method: TDDFT (RKS-based, GPU-accelerated)
Using full TDDFT - more accurate but slower
Calculating 10 excited states...


******** <class 'gpu4pyscf.tdscf.rks.TDDFT'> for <class 'gpu4pyscf.dft.rks.RKS'> ********
nstates = 10 singlet
deg_eia_thresh = 1.000e-03
wfnsym = None
conv_tol = 1e-05
eigh lindep = 1e-12
eigh level_shift = 0
eigh max_cycle = 100
chkfile = None
max_memory 4000 MB (current use 1094 MB)


Excited State energies (eV)
[2.22334014 2.8156715  2.82014644 3.14754923 3.3025886  3.32483771
 3.46033723 3.52020159 3.52261538 3.5319891 ]
✓ TDDFT converged (all states)

** Singlet excitation energies and oscillator strengths **
Excited State   1:      2.22334 eV    557.65 nm  f=0.6290
     100 -> 101       0.71134
Excited State   2:      2.81567 eV    440.34 nm  f=0.0001
      98 -> 103      -0.10997
      99 -> 101       0.69181
Excited State   3:      2.82015 eV    439.64 nm  f=0.0000
      98 -> 101       0.69165
      99 -> 103      -0.11057
Excited State   4:      3.14755 eV    393.91 nm  f=0.0000
      94 -> 101       0.17995
      97 -> 101       0.65194
     100 -> 104       0.11950
Excited State   5:      3.30259 eV    375.42 nm  f=0.0000
      94 -> 101       0.33540
      97 -> 101      -0.17816
     100 -> 102      -0.58936
Excited State   6:      3.32484 eV    372.90 nm  f=0.0000
      96 -> 101      -0.53767
     100 -> 103      -0.45021
Excited State   7:      3.46034 eV    358.30 nm  f=0.0706
      95 -> 101       0.66469
     100 -> 105      -0.16155
     100 -> 106      -0.14439
Excited State   8:      3.52020 eV    352.21 nm  f=0.0000
      93 -> 101      -0.67905
      99 -> 102      -0.10106
Excited State   9:      3.52262 eV    351.97 nm  f=0.0000
      90 -> 101      -0.13412
      94 -> 101      -0.52301
     100 -> 102      -0.31011
     100 -> 103       0.13952
     100 -> 104       0.28543
Excited State  10:      3.53199 eV    351.03 nm  f=0.0000
      92 -> 101      -0.67832
      98 -> 102      -0.10396

** Transition electric dipole moments (AU) **
state          X           Y           Z        Dip. S.      Osc.
  1         3.3981      0.0068      0.0000     11.5473      0.6290
  2        -0.0000      0.0000      0.0459      0.0021      0.0001
  3        -0.0000      0.0000      0.0046      0.0000      0.0000
  4         0.0011      0.0024     -0.0000      0.0000      0.0000
  5        -0.0023     -0.0037      0.0000      0.0000      0.0000
  6        -0.0008      0.0038      0.0000      0.0000      0.0000
  7        -0.0082      0.9124      0.0000      0.8325      0.0706
  8         0.0000     -0.0000      0.0025      0.0000      0.0000
  9         0.0011     -0.0067     -0.0000      0.0000      0.0000
 10        -0.0000      0.0000      0.0082      0.0001      0.0000

** Transition velocity dipole moments (imaginary part, AU) **
state          X           Y           Z        Dip. S.      Osc.
  1         0.2446      0.0006      0.0000      0.0598      0.4881
  2        -0.0000      0.0000      0.0052      0.0000      0.0002
  3        -0.0000      0.0000      0.0005      0.0000      0.0000
  4         0.0001      0.0003     -0.0000      0.0000      0.0000
  5        -0.0003     -0.0003     -0.0000      0.0000      0.0000
  6        -0.0001      0.0004      0.0000      0.0000      0.0000
  7        -0.0010      0.0969      0.0000      0.0094      0.0492
  8         0.0000     -0.0000      0.0007      0.0000      0.0000
  9         0.0001     -0.0008     -0.0000      0.0000      0.0000
 10        -0.0000      0.0000      0.0022      0.0000      0.0000

** Transition magnetic dipole moments (imaginary part, AU) **
state          X           Y           Z
  1        -0.0000     -0.0000     -0.0010
  2         0.0043     -0.0442      0.0000
  3        -0.0056      0.4677      0.0000
  4        -0.0000      0.0000      0.9900
  5         0.0000      0.0000     -1.0790
  6        -0.0000      0.0000      0.3650
  7        -0.0000      0.0000     -0.0236
  8         0.3437      0.0071     -0.0000
  9         0.0000      0.0000     -1.7909
 10        -0.1222     -0.0021      0.0000

======================================================================
EXCITED STATE ENERGIES
======================================================================
State 1: 0.081706 a.u. = 2.223 eV
State 2: 0.103474 a.u. = 2.816 eV
State 3: 0.103638 a.u. = 2.820 eV
State 4: 0.115670 a.u. = 3.148 eV
State 5: 0.121368 a.u. = 3.303 eV
State 6: 0.122186 a.u. = 3.325 eV
State 7: 0.127165 a.u. = 3.460 eV
State 8: 0.129365 a.u. = 3.520 eV
State 9: 0.129454 a.u. = 3.523 eV
State 10: 0.129798 a.u. = 3.532 eV
======================================================================

======================================================================
TRANSITION DIPOLE MOMENTS
======================================================================

Transition dipole moments (a.u.):
State    μ_x          μ_y          μ_z          |μ|          f           
----------------------------------------------------------------------
1           1.699061    0.003421    0.000000    1.699065    0.157248
2          -0.000000    0.000000    0.022947    0.022947    0.000036
3          -0.000000    0.000000    0.002285    0.002285    0.000000
4           0.000566    0.001183   -0.000000    0.001312    0.000000
5          -0.001167   -0.001871    0.000000    0.002205    0.000000
6          -0.000393    0.001876    0.000000    0.001917    0.000000
7          -0.004103    0.456198    0.000000    0.456217    0.017645
8           0.000000   -0.000000    0.001255    0.001255    0.000000
9           0.000535   -0.003361   -0.000000    0.003403    0.000001
10         -0.000000    0.000000    0.004121    0.004121    0.000001
======================================================================

======================================================================
NATURAL TRANSITION ORBITAL ANALYSIS
======================================================================

State 1 (2.223 eV):
State 1: 2.22334 eV  NTO largest component 0.97289341415256
    occ-NTO: 0.999951 (MO #100)
    vir-NTO: 0.999957 (MO #101)
  NTO orbitals saved to: output_gpu_charge0/nto_state_1.molden

State 2 (2.816 eV):
State 2: 2.81567 eV  NTO largest component 0.9642949275095969
    occ-NTO: 0.999151 (MO #99)
    vir-NTO: 0.997148 (MO #101)
  NTO orbitals saved to: output_gpu_charge0/nto_state_2.molden

State 3 (2.820 eV):
State 3: 2.82015 eV  NTO largest component 0.9639068484174682
    occ-NTO: 0.999154 (MO #98)
    vir-NTO: 0.997122 (MO #101)
  NTO orbitals saved to: output_gpu_charge0/nto_state_3.molden
======================================================================

======================================================================
TRANSITION CONTRIBUTION ANALYSIS
======================================================================
Analyzing orbital pair contributions to excited states...

======================================================================
STATE 1: 2.2233 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
1      HOMO → LUMO          0.977528     97.75       % 97.75       %
2      HOMO-6 → LUMO+1      0.022472     2.25        % 100.00      %
----------------------------------------------------------------------
Total weight analyzed: 0.758739

======================================================================
STATE 2: 2.8156 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
1      HOMO-1 → LUMO        0.976662     97.67       % 97.67       %
2      HOMO-2 → LUMO+2      0.023338     2.33        % 100.00      %
----------------------------------------------------------------------
Total weight analyzed: 0.965134

======================================================================
STATE 3: 2.8201 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
1      HOMO-2 → LUMO        0.976397     97.64       % 97.64       %
2      HOMO-1 → LUMO+2      0.023603     2.36        % 100.00      %
----------------------------------------------------------------------
Total weight analyzed: 0.964903

✓ Contribution tables saved to: output_gpu_charge0/contribution_tables.txt

======================================================================
GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES
======================================================================
Note: Cube files will be generated after grid parameters are calculated
      (see CUBE FILE GENERATION section below)
======================================================================

======================================================================
GRID PARAMETERS
======================================================================
Using box dimensions with margin: 4.0 Å
Grid spacing: 0.2 Å
Calculated grid resolution: 99 × 75 × 40
Total grid points: 297,000
Box size: [19.71000433 14.90917125  8.        ] Å
======================================================================

======================================================================
GENERATING HOMO/LUMO CUBE FILES
======================================================================
HOMO index: 99
LUMO index: 100
HOMO energy: -6.641 eV
LUMO energy: -4.445 eV
HOMO-LUMO gap: 2.196 eV

  ✓ HOMO orbital: output_gpu_charge0/HOMO.cube
  ✓ LUMO orbital: output_gpu_charge0/LUMO.cube
  ✓ HOMO-1 orbital: output_gpu_charge0/HOMO-1.cube
  ✓ LUMO+1 orbital: output_gpu_charge0/LUMO+1.cube

Verification tip:
For the first excited state (S1), check if the transition density
resembles a HOMO→LUMO transition by comparing:
  - transition_density_state1.cube
  - HOMO.cube (electron depletion)
  - LUMO.cube (electron accumulation)

----------------------------------------------------------------------
ANALYTICAL VERIFICATION: HOMO→LUMO Transition Density
----------------------------------------------------------------------
  ✓ Analytical HOMO→LUMO transition: output_gpu_charge0/transition_HOMO_LUMO_analytical.cube

To verify S1 is a HOMO→LUMO transition, compare:
  1. output_gpu_charge0/transition_density_state1.cube
  2. output_gpu_charge0/transition_HOMO_LUMO_analytical.cube

They should be very similar if S1 is dominated by HOMO→LUMO excitation.
You can calculate the overlap/similarity in VMD or by visual inspection.
======================================================================

======================================================================
GENERATING EXCITED STATE CUBE FILES
======================================================================
Generating cube files for states: [1, 2, 3]
Grid resolution: 99 × 75 × 40

State 1: 2.223 eV
  ✓ Transition density: output_gpu_charge0/transition_density_state1.cube
  ✓ Excited state density: output_gpu_charge0/excited_state_density_state1.cube
  ✓ Density difference: output_gpu_charge0/density_difference_state1.cube

  ------------------------------------------------------------------
  QUANTITATIVE VERIFICATION: S1 vs HOMO→LUMO
  ------------------------------------------------------------------
  Similarity (cosine): 0.8790
  HOMO→LUMO weight: 0.9335 (93.4%)
  HOMO→LUMO amplitude: 0.8612
  ✓ S1 is MOSTLY a HOMO→LUMO transition
  ------------------------------------------------------------------

State 2: 2.816 eV
  ✓ Transition density: output_gpu_charge0/transition_density_state2.cube
  ✓ Excited state density: output_gpu_charge0/excited_state_density_state2.cube
  ✓ Density difference: output_gpu_charge0/density_difference_state2.cube

State 3: 2.820 eV
  ✓ Transition density: output_gpu_charge0/transition_density_state3.cube
  ✓ Excited state density: output_gpu_charge0/excited_state_density_state3.cube
  ✓ Density difference: output_gpu_charge0/density_difference_state3.cube
======================================================================

======================================================================
GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES
======================================================================

State 1 (2.2233 eV):
  ✓ Rank 1: HOMO → LUMO (97.75%) → output_gpu_charge0/transition_pair_state1_HOMO_to_LUMO.cube
  Skipping HOMO-6 → LUMO+1 (contribution 2.25% < 5%)

State 2 (2.8156 eV):
  ✓ Rank 1: HOMO-1 → LUMO (97.67%) → output_gpu_charge0/transition_pair_state2_HOMOm1_to_LUMO.cube
  Skipping HOMO-2 → LUMO+2 (contribution 2.33% < 5%)

State 3 (2.8201 eV):
  ✓ Rank 1: HOMO-2 → LUMO (97.64%) → output_gpu_charge0/transition_pair_state3_HOMOm2_to_LUMO.cube
  Skipping HOMO-1 → LUMO+2 (contribution 2.36% < 5%)
======================================================================

======================================================================
CALCULATION SUMMARY
======================================================================

Molecule: XYZ file: PTCDA_clean.xyz
Basis set: 6-31g
Number of atoms: 38
Number of electrons: 200
Number of basis functions: 286
Molecular charge: 0
Spin multiplicity: 1 (closed-shell)

Computational settings:
  DFT method: RKS
  XC functional: b3lyp
  Parallel threads: auto-detected
  TDDFT method: Full TDDFT (not TDA)
  Number of excited states calculated: 10

Grid settings:
  Mode: Box dimensions
  Margin: 4.0 Å, Spacing: 0.2 Å
  Grid: 99 × 75 × 40 = 297,000 points

Output files generated:
  ✓ HOMO/LUMO orbitals (in output_gpu_charge0/)
  ✓ NTO analysis for 3 state(s)
  ✓ Cube files for 3 state(s):
    - Transition density matrices
    - Excited state densities
    - Density differences

All output files saved to: output_gpu_charge0/

======================================================================
VISUALIZATION GUIDE
======================================================================

Three types of cube files generated:

1. transition_density_state*.cube
   - Represents the electronic transition between ground and excited state
   - Used for calculating transition dipole moments
   - Visualize with isovalues ±0.002

2. excited_state_density_state*.cube
   - Total electron density in the excited state
   - Compare with ground state density

3. density_difference_state*.cube
   - Change in electron density (excited - ground)
   - Red/positive: electron accumulation
   - Blue/negative: electron depletion
   - Recommended for visualization

VMD visualization:
  vmd output/density_difference_state1.cube
  Graphics > Representations > Drawing Method: Isosurface
  - Rep 1: Isovalue = +0.002, Color = Red (electron gain)
  - Rep 2: Isovalue = -0.002, Color = Blue (electron loss)

Jmol visualization:
  isosurface ID "surf1" cutoff  0.002 output/density_difference_state1.cube
  isosurface ID "surf2" cutoff -0.002 output/density_difference_state1.cube

HOMO/LUMO verification:
  Compare transition_density_state1.cube with HOMO.cube and LUMO.cube
  to verify that S1 corresponds to a HOMO→LUMO transition.

NTO visualization:
  Open output/nto_state_*.molden files in Jmol, Avogadro, or VMD

======================================================================

✓ Calculation completed successfully!
✓ All files saved to: output_gpu_charge0/

