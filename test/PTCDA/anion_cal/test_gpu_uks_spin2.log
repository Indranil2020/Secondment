
Parallel computation enabled: 12 threads (auto-detected)

======================================================================
MOLECULE SETUP
======================================================================
Using H2O test molecule
Basis set: 6-31g
#INFO: **** input file is /home/indranil/Documents/Secondment/test/PTCDA/anion_cal/tdm_calc_accurate_GPU.py ****
#!/usr/bin/env python
'''
GPU-Accelerated Transition Density Matrix Calculation
Based on official PySCF examples with GPU4PySCF support

Features:
- GPU acceleration for DFT and TDDFT (B3LYP, UKS fully supported)
- Parallel calculation support
- Configurable grid size and box dimensions
- Selective state output
- HOMO/LUMO cube file generation

Requirements:
- pip install gpu4pyscf-cuda12x
- pip install cutensor-cu12 (optional, for 10-20% better performance)
'''

from pyscf import gto, lib
from pyscf.tools import cubegen, molden
from gpu4pyscf import dft
from gpu4pyscf.tdscf import rks as gpu_tdrks, uks as gpu_tduks
import numpy as np
from functools import reduce
import os

# ============================================================================
# CONFIGURATION SECTION - MODIFY THESE SETTINGS
# ============================================================================

# --- Parallel Calculation Settings ---
# Note: GPU handles DFT/TDDFT parallelization automatically
ENABLE_PARALLEL = True  # Enable/disable parallel computation for CPU operations
NUM_THREADS = 0  # Number of CPU threads for non-GPU operations (0 = auto-detect)

# --- Molecule Selection ---
USE_XYZ = False  # True: use XYZ file, False: use H2O test molecule
XYZ_FILE = 'PTCDA_clean.xyz'  # Path to XYZ file
BASIS_SET = '6-31g'  # Basis set

# --- Charge and Spin Settings ---
CHARGE = -1 # Molecular charge: 0 (neutral), +1 (cation), -1 (anion)
SPIN = 2  # Spin multiplicity (2S+1): None = auto-calculate, 1 = singlet, 2 = doublet, 3 = triplet
# Note: Spin is auto-calculated from electron count if set to None
# For charged systems: cation (+1) typically has spin=2 (doublet), anion (-1) has spin=2 (doublet)
# Neutral even-electron systems typically have spin=1 (singlet)

# --- DFT/TDDFT Settings ---
# Note: TDDFT uses the same basis set and XC functional as ground state DFT
XC_FUNCTIONAL = 'b3lyp'  # Exchange-correlation functional
# Common options:
#   'b3lyp'    - B3LYP (hybrid, good general purpose)
#   'pbe0'     - PBE0 (hybrid, good for excited states)
#   'cam-b3lyp' - CAM-B3LYP (range-separated, good for charge transfer)
#   'wb97x-d'  - ωB97X-D (range-separated with dispersion)
#   'pbe'      - PBE (GGA, faster but less accurate)
#   'blyp'     - BLYP (GGA)

NUM_EXCITED_STATES = 10  # Total number of excited states to calculate

# --- TDDFT Method Selection ---
USE_TDA = False  # True: TDA (2× faster, ~95% accurate), False: Full TDDFT (slower, more accurate)
# TDA (Tamm-Dancoff Approximation) is recommended for large systems or initial testing
# For charged/open-shell systems, TDDFT automatically uses appropriate method
# Closed-shell (spin=1): Uses RKS/TDDFT or RKS/TDA
# Open-shell (spin>1): Uses UKS/TDDFT or UKS/TDA

# --- Output Selection ---
# STATES_TO_OUTPUT: Which states to generate CUBE FILES for (0-indexed)
# Cube files are large (~150-500 MB per state), so be selective
# Examples:
#   [0, 1, 2] - First three states
#   [0, 4, 9] - States 1, 5, and 10
#   range(5) - First five states
STATES_TO_OUTPUT = [0, 1, 2]  # Cube files: transition density, excited density, density difference

# --- Cube File Generation Options ---
GENERATE_TRANSITION_DENSITY = True  # Transition density matrix
GENERATE_EXCITED_DENSITY = True     # Excited state density
GENERATE_DENSITY_DIFFERENCE = True  # Density difference (excited - ground)
GENERATE_HOMO_LUMO = True           # HOMO and LUMO orbitals for verification

# --- Grid Settings ---
# Option 1: Use grid resolution (number of points per axis)
USE_GRID_RESOLUTION = False
GRID_RESOLUTION = [80, 80, 80]  # [nx, ny, nz] grid points

# Option 2: Use box dimensions (in Angstrom) - only used if USE_GRID_RESOLUTION = False
BOX_MARGIN = 4.0  # Margin around molecule in Angstrom
GRID_SPACING = 0.2  # Grid spacing in Angstrom

# --- NTO Analysis ---
# NTO_STATES: Which states to perform NTO ANALYSIS for (0-indexed)
# NTO molden files are small (~5 MB per state), so you can analyze more states
# This is INDEPENDENT of STATES_TO_OUTPUT - you can have different lists
# Example: Generate cube files for [0,1] but NTO analysis for [0,1,2,3,4]
ENABLE_NTO_ANALYSIS = True  # Generate NTO molden files
NTO_STATES = [0, 1, 2]  # NTO analysis (can be different from STATES_TO_OUTPUT)

# --- Output Directory ---
OUTPUT_DIR = 'output_gpu'  # Directory for output files (created if doesn't exist)

# ============================================================================
# END OF CONFIGURATION
# ============================================================================

# ============================================================================
# SETUP AND INITIALIZATION
# ============================================================================

# Create output directory
if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)
    print(f"Created output directory: {OUTPUT_DIR}")

# Setup parallel computation
if ENABLE_PARALLEL:
    if NUM_THREADS > 0:
        lib.num_threads(NUM_THREADS)
        print(f"\nParallel computation enabled: {NUM_THREADS} threads")
    else:
        # Auto-detect number of cores
        import multiprocessing
        num_cores = multiprocessing.cpu_count()
        lib.num_threads(num_cores)
        print(f"\nParallel computation enabled: {num_cores} threads (auto-detected)")
else:
    lib.num_threads(1)
    print("\nParallel computation disabled: using 1 thread")

# ============================================================================
# 1. MOLECULE DEFINITION
# ============================================================================

def create_h2o_molecule():
    """Create H2O test molecule"""
    mol = gto.M(
        atom = '''
        O  0.0000  0.0000  0.1173
        H  0.0000  0.7572 -0.4692
        H  0.0000 -0.7572 -0.4692
        ''',
        basis = BASIS_SET,
        verbose = 4
    )
    return mol

def calculate_spin_multiplicity(n_electrons, charge):
    """
    Calculate spin multiplicity (2S+1) from electron count.
    
    Args:
        n_electrons: Total number of electrons in neutral molecule
        charge: Molecular charge
    
    Returns:
        spin: Spin multiplicity (2S+1)
    """
    # Adjust electron count for charge
    n_elec = n_electrons - charge
    
    # For even number of electrons: singlet (spin=1)
    # For odd number of electrons: doublet (spin=2)
    if n_elec % 2 == 0:
        spin = 1  # Singlet (closed-shell)
    else:
        spin = 2  # Doublet (open-shell)
    
    return spin

def create_molecule_from_xyz(xyz_file, basis, charge=0, spin=None):
    """
    Load molecule from XYZ file with charge and spin.
    
    Args:
        xyz_file: Path to XYZ file
        basis: Basis set
        charge: Molecular charge
        spin: Spin multiplicity (None = auto-calculate)
    """
    # First, create molecule to get electron count
    mol_temp = gto.M(atom=xyz_file, basis=basis, charge=0, spin=0, verbose=0)
    n_electrons = mol_temp.nelectron
    
    # Calculate spin if not provided
    if spin is None:
        spin = calculate_spin_multiplicity(n_electrons, charge)
    
    # Create final molecule with charge and spin
    mol = gto.M(
        atom = xyz_file,
        basis = basis,
        charge = charge,
        spin = spin - 1,  # PySCF uses 2S (number of unpaired electrons), not 2S+1
        verbose = 4
    )
    
    return mol, spin

print("\n" + "="*70)
print("MOLECULE SETUP")
print("="*70)

if USE_XYZ:
    print(f"Loading molecule from: {XYZ_FILE}")
    print(f"Basis set: {BASIS_SET}")
    print(f"Charge: {CHARGE}")
    mol, calculated_spin = create_molecule_from_xyz(XYZ_FILE, BASIS_SET, CHARGE, SPIN)
    actual_spin = calculated_spin
else:
    print("Using H2O test molecule")
    print(f"Basis set: {BASIS_SET}")
    mol = create_h2o_molecule()
    actual_spin = 1  # H2O is singlet

print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity (2S+1): {actual_spin}")
print(f"Number of unpaired electrons (2S): {mol.spin}")

if actual_spin == 1:
    print("System type: Closed-shell (singlet)")
    dft_method = "RKS"
else:
    print(f"System type: Open-shell ({['singlet', 'doublet', 'triplet', 'quartet', 'quintet'][actual_spin-1] if actual_spin <= 5 else f'spin={actual_spin}'})")
    dft_method = "UKS"

print(f"DFT method: {dft_method} (GPU-accelerated)")

# ============================================================================
# 2. GROUND STATE DFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("GROUND STATE DFT CALCULATION")
print("="*70)
print(f"XC functional: {XC_FUNCTIONAL}")
print(f"Basis set: {BASIS_SET}")
print(f"Method: {dft_method} (GPU-accelerated)")

# Select RKS (closed-shell) or UKS (open-shell) based on spin
if actual_spin == 1:
    mf = dft.RKS(mol)
else:
    mf = dft.UKS(mol)

mf.xc = XC_FUNCTIONAL
mf.kernel()

if not mf.converged:
    print("WARNING: SCF did not converge!")
    print("Try: 1) Different initial guess, 2) Level shifting, 3) DIIS settings")
else:
    print("✓ SCF converged")

print(f"Ground state energy: {mf.e_tot:.6f} a.u.")

# ============================================================================
# 3. TDDFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("TDDFT CALCULATION")
print("="*70)
print(f"Note: TDDFT inherits XC functional ({XC_FUNCTIONAL}) and basis set ({BASIS_SET}) from ground state")
method_name = 'TDA' if USE_TDA else 'TDDFT'
spin_type = 'RKS' if actual_spin == 1 else 'UKS'
print(f"TDDFT method: {method_name} ({spin_type}-based, GPU-accelerated)")

# Select TDA or full TDDFT
# Use gpu4pyscf.tdscf module (RKS or UKS based on spin)
if actual_spin == 1:
    # Closed-shell: use gpu4pyscf.tdscf.rks
    if USE_TDA:
        td = gpu_tdrks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tdrks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
else:
    # Open-shell: use gpu4pyscf.tdscf.uks
    if USE_TDA:
        td = gpu_tduks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tduks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
td.nstates = NUM_EXCITED_STATES
print(f"Calculating {NUM_EXCITED_STATES} excited states...")
td.kernel()

# Handle both RKS (scalar) and UKS (array) convergence
if hasattr(td.converged, '__len__'):  # UKS: array
    if not td.converged.all():
        print(f"WARNING: TDDFT did not converge for some states!")
        print(f"  Converged states: {td.converged.sum()}/{len(td.converged)}")
    else:
        print("✓ TDDFT converged (all states)")
else:  # RKS: scalar
    if not td.converged:
        print("WARNING: TDDFT did not converge!")
    else:
        print("✓ TDDFT converged")

td.analyze()  # Print detailed analysis

# Print excitation energies
print("\n" + "="*70)
print("EXCITED STATE ENERGIES")
print("="*70)
for i, energy in enumerate(td.e):
    print(f"State {i+1}: {energy:.6f} a.u. = {energy*27.211:.3f} eV")
print("="*70)

# ============================================================================
# 4. TRANSITION DIPOLE MOMENTS
# ============================================================================

print("\n" + "="*70)
print("TRANSITION DIPOLE MOMENTS")
print("="*70)

# Set gauge origin to nuclear charge center
charges = mol.atom_charges()
coords = mol.atom_coords()  # in a.u.
nuc_charge_center = np.einsum('z,zx->x', charges, coords) / charges.sum()
mol.set_common_orig_(nuc_charge_center)

# Calculate dipole integrals
dip_ints = mol.intor('cint1e_r_sph', comp=3)  # x, y, z components

def calculate_transition_dipole(td, state_id):
    """
    Calculate transition dipole moment for a given excited state.
    Based on PySCF example: examples/1-advanced/030-transition_dipole.py
    
    Handles both RKS (closed-shell) and UKS (open-shell) cases.
    For GPU4PySCF, converts CuPy arrays to NumPy arrays.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    tdm : ndarray, shape (3,)
        Transition dipole moment [x, y, z] in a.u.
    """
    # Get TDDFT amplitudes (X and Y vectors)
    X, Y = td.xy[state_id]
    
    # Get MO coefficients and occupations
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    
    # Check if UKS by checking if X is a tuple (more reliable than mo_coeff)
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS: mo_coeff and mo_occ are tuples (alpha, beta)
        # For UKS, X and Y are also tuples: ((Xa, Xb), (Ya, Yb))
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        # Xa and Xb are already separated, just need to get dimensions
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Transition density matrices for alpha and beta
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        # Total transition density (alpha + beta)
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
        
    else:
        # RKS: mo_coeff and mo_occ are arrays
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        # Transition density in MO basis
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        
        # Transform to AO basis
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    # Calculate transition dipole: μ = Tr(μ_op * T)
    tdm = np.einsum('xij,ji->x', dip_ints, t_dm1_ao)
    
    return tdm

# Calculate and print transition dipoles for all states
print("\nTransition dipole moments (a.u.):")
print(f"{'State':<8} {'μ_x':<12} {'μ_y':<12} {'μ_z':<12} {'|μ|':<12} {'f':<12}")
print("-" * 70)

for i in range(td.nstates):
    tdm = calculate_transition_dipole(td, i)
    tdm_magnitude = np.linalg.norm(tdm)
    
    # Oscillator strength: f = (2/3) * ω * |μ|^2
    # where ω is excitation energy in a.u.
    omega = td.e[i]
    osc_strength = (2.0/3.0) * omega * tdm_magnitude**2
    
    print(f"{i+1:<8} {tdm[0]:>11.6f} {tdm[1]:>11.6f} {tdm[2]:>11.6f} "
          f"{tdm_magnitude:>11.6f} {osc_strength:>11.6f}")

print("="*70)

# ============================================================================
# 5. TRANSITION DENSITY MATRICES
# ============================================================================

def calculate_transition_density_matrix(td, state_id):
    """
    Calculate transition density matrix between ground and excited state.
    This is the proper transition density for visualization.
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    t_dm1_ao : ndarray
        Transition density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Alpha
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_mo_a[nocc_a:, :nocc_a] = (Xa + Ya).T
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        # Beta
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_mo_b[nocc_b:, :nocc_b] = (Xb + Yb).T
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
    else:
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        t_dm1_mo[nocc:, :nocc] = (X + Y).reshape(nocc, nvir).T
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    return t_dm1_ao

def calculate_excited_state_density(td, state_id):
    """
    Calculate excited state density matrix.
    Based on PySCF examples/tddft/22-density.py
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    dm_excited : ndarray
        Excited state density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mf = td._scf
    mo_coeff = mf.mo_coeff
    mo_occ = mf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS case - simplified approach: use transition density
        # For visualization, transition density is more meaningful
        return calculate_transition_density_matrix(td, state_id)
    else:
        # RKS case
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        nocc = X.shape[0]
        
        # Density matrix changes in MO basis
        dm_oo = -np.einsum('ia,ka->ik', X.conj(), X)
        dm_oo -= np.einsum('ia,ka->ik', Y.conj(), Y)
        
        dm_vv = np.einsum('ia,ic->ac', X, X.conj())
        dm_vv += np.einsum('ia,ic->ac', Y, Y.conj())
        
        # Start with ground state density in MO basis
        dm = np.diag(mo_occ)
        
        # Add TDDFT contribution
        dm[:nocc, :nocc] += dm_oo * 2
        dm[nocc:, nocc:] += dm_vv * 2
        
        # Transform to AO basis
        dm_excited = np.einsum('pi,ij,qj->pq', mo_coeff, dm, mo_coeff.conj())
    
    return dm_excited

# ============================================================================
# 6. NATURAL TRANSITION ORBITALS (NTO) ANALYSIS
# ============================================================================

if ENABLE_NTO_ANALYSIS:
    print("\n" + "="*70)
    print("NATURAL TRANSITION ORBITAL ANALYSIS")
    print("="*70)
    
    # Filter valid NTO states
    valid_nto_states = [s for s in NTO_STATES if s < td.nstates]
    
    if not valid_nto_states:
        print("No valid NTO states selected.")
    else:
        for i in valid_nto_states:
            print(f"\nState {i+1} ({td.e[i]*27.211:.3f} eV):")
            weights, nto_coeff = td.get_nto(state=i+1, verbose=4)
            
            # Save NTO orbitals to molden format for visualization
            # For UKS, nto_coeff is a tuple (alpha, beta)
            if isinstance(nto_coeff, tuple):
                # Save alpha NTOs
                molden_file_a = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_alpha.molden')
                molden.from_mo(mol, molden_file_a, nto_coeff[0])
                print(f"  Alpha NTO orbitals saved to: {molden_file_a}")
                
                # Save beta NTOs
                molden_file_b = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_beta.molden')
                molden.from_mo(mol, molden_file_b, nto_coeff[1])
                print(f"  Beta NTO orbitals saved to: {molden_file_b}")
            else:
                # RKS case
                molden_file = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}.molden')
                molden.from_mo(mol, molden_file, nto_coeff)
                print(f"  NTO orbitals saved to: {molden_file}")
    
    print("="*70)
else:
    print("\nNTO analysis disabled.")

# ============================================================================
# 7. CALCULATE GRID PARAMETERS
# ============================================================================

def calculate_grid_parameters(mol, use_resolution=True, resolution=None, 
                             box_margin=4.0, grid_spacing=0.2):
    """
    Calculate grid parameters for cube file generation.
    
    Parameters:
    -----------
    mol : Mole object
    use_resolution : bool
        If True, use fixed resolution. If False, calculate from box dimensions.
    resolution : list [nx, ny, nz]
        Grid resolution (number of points per axis)
    box_margin : float
        Margin around molecule in Angstrom
    grid_spacing : float
        Grid spacing in Angstrom
    
    Returns:
    --------
    nx, ny, nz : int
        Grid resolution
    box_info : dict
        Box dimension information
    """
    # Get molecular coordinates in Angstrom
    coords = mol.atom_coords() * 0.529177  # Bohr to Angstrom
    
    # Calculate bounding box
    min_coords = coords.min(axis=0)
    max_coords = coords.max(axis=0)
    mol_size = max_coords - min_coords
    
    box_info = {
        'min_coords': min_coords,
        'max_coords': max_coords,
        'mol_size': mol_size,
        'box_margin': box_margin
    }
    
    if use_resolution:
        nx, ny, nz = resolution
        actual_spacing = mol_size / np.array([nx, ny, nz])
        box_info['grid_spacing'] = actual_spacing
        box_info['total_points'] = nx * ny * nz
    else:
        # Calculate grid points from spacing and box size
        box_size = mol_size + 2 * box_margin
        nx = int(np.ceil(box_size[0] / grid_spacing))
        ny = int(np.ceil(box_size[1] / grid_spacing))
        nz = int(np.ceil(box_size[2] / grid_spacing))
        box_info['grid_spacing'] = [grid_spacing] * 3
        box_info['box_size'] = box_size
        box_info['total_points'] = nx * ny * nz
    
    return nx, ny, nz, box_info

# Calculate grid parameters
print("\n" + "="*70)
print("GRID PARAMETERS")
print("="*70)

if USE_GRID_RESOLUTION:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=True, resolution=GRID_RESOLUTION
    )
    print(f"Using fixed grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Molecule size: {box_info['mol_size']} Å")
    print(f"Effective grid spacing: {box_info['grid_spacing']} Å")
else:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=False, box_margin=BOX_MARGIN, 
        grid_spacing=GRID_SPACING
    )
    print(f"Using box dimensions with margin: {BOX_MARGIN} Å")
    print(f"Grid spacing: {GRID_SPACING} Å")
    print(f"Calculated grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Box size: {box_info['box_size']} Å")

print("="*70)

# ============================================================================
# 8. GENERATE HOMO/LUMO CUBE FILES
# ============================================================================

if GENERATE_HOMO_LUMO:
    print("\n" + "="*70)
    print("GENERATING HOMO/LUMO CUBE FILES")
    print("="*70)
    
    # Get HOMO and LUMO indices (handle both RKS and UKS)
    if actual_spin == 1:  # RKS (closed-shell)
        mo_occ = mf.mo_occ
        mo_coeff = mf.mo_coeff
        mo_energy = mf.mo_energy
    else:  # UKS (open-shell) - use alpha orbitals
        mo_occ = mf.mo_occ[0]  # Alpha occupation
        mo_coeff = mf.mo_coeff[0]  # Alpha coefficients
        mo_energy = mf.mo_energy[0]  # Alpha energies
        print("Note: Using alpha orbitals for HOMO/LUMO (open-shell system)")
    
    # Convert CuPy to NumPy if needed
    if hasattr(mo_occ, 'get'):
        mo_occ = mo_occ.get()
        mo_coeff = mo_coeff.get()
        mo_energy = mo_energy.get()
    
    homo_idx = np.where(mo_occ > 0)[0][-1]
    lumo_idx = np.where(mo_occ == 0)[0][0]
    
    print(f"HOMO index: {homo_idx}")
    print(f"LUMO index: {lumo_idx}")
    print(f"HOMO energy: {mo_energy[homo_idx]*27.211:.3f} eV")
    print(f"LUMO energy: {mo_energy[lumo_idx]*27.211:.3f} eV")
    print(f"HOMO-LUMO gap: {(mo_energy[lumo_idx] - mo_energy[homo_idx])*27.211:.3f} eV")
    
    # Generate HOMO cube file
    homo_file = os.path.join(OUTPUT_DIR, 'HOMO.cube')
    cubegen.orbital(mol, homo_file, mo_coeff[:, homo_idx], nx=nx, ny=ny, nz=nz)
    print(f"\n  ✓ HOMO orbital: {homo_file}")
    
    # Generate LUMO cube file
    lumo_file = os.path.join(OUTPUT_DIR, 'LUMO.cube')
    cubegen.orbital(mol, lumo_file, mo_coeff[:, lumo_idx], nx=nx, ny=ny, nz=nz)
    print(f"  ✓ LUMO orbital: {lumo_file}")
    
    # Generate HOMO-1 and LUMO+1 for additional verification
    if homo_idx > 0:
        homo1_file = os.path.join(OUTPUT_DIR, 'HOMO-1.cube')
        cubegen.orbital(mol, homo1_file, mo_coeff[:, homo_idx-1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ HOMO-1 orbital: {homo1_file}")
    
    if lumo_idx < len(mo_occ) - 1:
        lumo1_file = os.path.join(OUTPUT_DIR, 'LUMO+1.cube')
        cubegen.orbital(mol, lumo1_file, mo_coeff[:, lumo_idx+1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ LUMO+1 orbital: {lumo1_file}")
    
    print("\nVerification tip:")
    print("For the first excited state (S1), check if the transition density")
    print("resembles a HOMO→LUMO transition by comparing:")
    print("  - transition_density_state1.cube")
    print("  - HOMO.cube (electron depletion)")
    print("  - LUMO.cube (electron accumulation)")
    
    # Analytical verification: Calculate HOMO→LUMO transition density
    print("\n" + "-"*70)
    print("ANALYTICAL VERIFICATION: HOMO→LUMO Transition Density")
    print("-"*70)
    
    # Construct approximate HOMO→LUMO transition density matrix
    homo_mo = mo_coeff[:, homo_idx]
    lumo_mo = mo_coeff[:, lumo_idx]
    
    # T_approx = |HOMO⟩⟨LUMO| + |LUMO⟩⟨HOMO|
    # In AO basis: T_μν = C_μ^HOMO * C_ν^LUMO + C_μ^LUMO * C_ν^HOMO
    t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
    
    # Generate cube file for HOMO→LUMO transition density
    homo_lumo_file = os.path.join(OUTPUT_DIR, 'transition_HOMO_LUMO_analytical.cube')
    cubegen.density(mol, homo_lumo_file, t_homo_lumo, nx=nx, ny=ny, nz=nz)
    print(f"  ✓ Analytical HOMO→LUMO transition: {homo_lumo_file}")
    
    print("\nTo verify S1 is a HOMO→LUMO transition, compare:")
    print(f"  1. {os.path.join(OUTPUT_DIR, 'transition_density_state1.cube')}")
    print(f"  2. {homo_lumo_file}")
    print("\nThey should be very similar if S1 is dominated by HOMO→LUMO excitation.")
    print("You can calculate the overlap/similarity in VMD or by visual inspection.")
    
    print("="*70)
else:
    print("\nHOMO/LUMO generation disabled.")

# ============================================================================
# 9. GENERATE CUBE FILES FOR SELECTED EXCITED STATES
# ============================================================================

print("\n" + "="*70)
print("GENERATING EXCITED STATE CUBE FILES")
print("="*70)

# Filter valid states
valid_states = [s for s in STATES_TO_OUTPUT if s < td.nstates]

if not valid_states:
    print("No valid states selected for cube file generation.")
else:
    print(f"Generating cube files for states: {[s+1 for s in valid_states]}")
    print(f"Grid resolution: {nx} × {ny} × {nz}")
    
    for state_id in valid_states:
        print(f"\nState {state_id+1}: {td.e[state_id]*27.211:.3f} eV")
        
        # 1. Transition density matrix
        if GENERATE_TRANSITION_DENSITY:
            dm_trans = calculate_transition_density_matrix(td, state_id)
            filename_trans = os.path.join(OUTPUT_DIR, f'transition_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_trans, dm_trans, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Transition density: {filename_trans}")
        
        # 2. Excited state density
        if GENERATE_EXCITED_DENSITY:
            dm_excited = calculate_excited_state_density(td, state_id)
            filename_excited = os.path.join(OUTPUT_DIR, f'excited_state_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_excited, dm_excited, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Excited state density: {filename_excited}")
        
        # 3. Density difference
        if GENERATE_DENSITY_DIFFERENCE:
            if not GENERATE_EXCITED_DENSITY:
                dm_excited = calculate_excited_state_density(td, state_id)
            
            # Get ground state density and convert CuPy to NumPy if needed
            dm_ground = mf.make_rdm1()
            if hasattr(dm_ground, 'get'):
                dm_ground = dm_ground.get()
            
            # For UKS, dm_ground is a tuple (alpha, beta), sum them
            if isinstance(dm_ground, tuple):
                dm_ground = dm_ground[0] + dm_ground[1]
            
            dm_diff = dm_excited - dm_ground
            filename_diff = os.path.join(OUTPUT_DIR, f'density_difference_state{state_id+1}.cube')
            cubegen.density(mol, filename_diff, dm_diff, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Density difference: {filename_diff}")
        
        # Quantitative verification for first state
        if state_id == 0 and GENERATE_HOMO_LUMO and GENERATE_TRANSITION_DENSITY:
            print("\n  " + "-"*66)
            print("  QUANTITATIVE VERIFICATION: S1 vs HOMO→LUMO")
            print("  " + "-"*66)
            
            # Get HOMO and LUMO indices (handle both RKS and UKS)
            if actual_spin == 1:
                mo_occ_ver = mf.mo_occ
                mo_coeff_ver = mf.mo_coeff
            else:
                mo_occ_ver = mf.mo_occ[0]
                mo_coeff_ver = mf.mo_coeff[0]
            
            # Convert CuPy to NumPy if needed
            if hasattr(mo_occ_ver, 'get'):
                mo_occ_ver = mo_occ_ver.get()
                mo_coeff_ver = mo_coeff_ver.get()
            
            homo_idx = np.where(mo_occ_ver > 0)[0][-1]
            lumo_idx = np.where(mo_occ_ver == 0)[0][0]
            
            # Calculate analytical HOMO→LUMO transition density
            homo_mo = mo_coeff_ver[:, homo_idx]
            lumo_mo = mo_coeff_ver[:, lumo_idx]
            t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
            
            # Get TDDFT transition density for S1
            dm_trans_s1 = calculate_transition_density_matrix(td, 0)
            
            # Calculate overlap/similarity (Frobenius inner product)
            overlap = np.sum(dm_trans_s1 * t_homo_lumo)
            norm_tddft = np.linalg.norm(dm_trans_s1)
            norm_homo_lumo = np.linalg.norm(t_homo_lumo)
            similarity = overlap / (norm_tddft * norm_homo_lumo)
            
            # Calculate HOMO→LUMO contribution from TDDFT amplitudes
            X, Y = td.xy[0]
            
            # For UKS, X and Y are tuples (Xa, Xb), (Ya, Yb)
            if actual_spin > 1:
                Xa, Xb = X
                Ya, Yb = Y
                # Convert CuPy to NumPy if needed
                if hasattr(Xa, 'get'):
                    Xa = Xa.get()
                    Ya = Ya.get()
                # Use only alpha part for verification
                # HOMO is last occupied (nocc_a-1), LUMO is first virtual (0)
                homo_lumo_amplitude = abs(Xa[-1, 0] + Ya[-1, 0])
                total_amplitude = np.linalg.norm(Xa + Ya)
            else:
                # Convert CuPy to NumPy if needed
                if hasattr(X, 'get'):
                    X = X.get()
                    Y = Y.get()
                nocc = X.shape[0]
                nvir = X.shape[1]
                # HOMO is index nocc-1 in occupied space, LUMO is index 0 in virtual space
                homo_lumo_amplitude = abs(X[nocc-1, 0] + Y[nocc-1, 0])
                total_amplitude = np.linalg.norm(X + Y)
            
            homo_lumo_weight = (homo_lumo_amplitude / total_amplitude)**2
            
            print(f"  Similarity (cosine): {similarity:.4f}")
            print(f"  HOMO→LUMO weight: {homo_lumo_weight:.4f} ({homo_lumo_weight*100:.1f}%)")
            print(f"  HOMO→LUMO amplitude: {homo_lumo_amplitude:.4f}")
            
            if similarity > 0.95 and homo_lumo_weight > 0.8:
                print("  ✓ S1 is STRONGLY dominated by HOMO→LUMO transition")
            elif similarity > 0.85 and homo_lumo_weight > 0.6:
                print("  ✓ S1 is MOSTLY a HOMO→LUMO transition")
            elif similarity > 0.70 and homo_lumo_weight > 0.4:
                print("  ⚠ S1 has SIGNIFICANT HOMO→LUMO character but mixed")
            else:
                print("  ⚠ S1 is NOT a pure HOMO→LUMO transition (multi-configurational)")
            
            print("  " + "-"*66)

print("="*70)

# ============================================================================
# 10. CALCULATION SUMMARY
# ============================================================================

print("\n" + "="*70)
print("CALCULATION SUMMARY")
print("="*70)

print(f"\nMolecule: {'XYZ file: ' + XYZ_FILE if USE_XYZ else 'H2O test molecule'}")
print(f"Basis set: {BASIS_SET}")
print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity: {actual_spin} ({'closed-shell' if actual_spin == 1 else 'open-shell'})")

print(f"\nComputational settings:")
print(f"  DFT method: {dft_method}")
print(f"  XC functional: {XC_FUNCTIONAL}")
print(f"  Parallel threads: {NUM_THREADS if NUM_THREADS > 0 else 'auto-detected'}")
print(f"  TDDFT method: Full TDDFT (not TDA)")
print(f"  Number of excited states calculated: {NUM_EXCITED_STATES}")

print(f"\nGrid settings:")
if USE_GRID_RESOLUTION:
    print(f"  Mode: Fixed resolution")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")
else:
    print(f"  Mode: Box dimensions")
    print(f"  Margin: {BOX_MARGIN} Å, Spacing: {GRID_SPACING} Å")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")

print(f"\nOutput files generated:")
if GENERATE_HOMO_LUMO:
    print(f"  ✓ HOMO/LUMO orbitals (in {OUTPUT_DIR}/)")
if ENABLE_NTO_ANALYSIS and valid_nto_states:
    print(f"  ✓ NTO analysis for {len(valid_nto_states)} state(s)")
if valid_states:
    print(f"  ✓ Cube files for {len(valid_states)} state(s):")
    if GENERATE_TRANSITION_DENSITY:
        print(f"    - Transition density matrices")
    if GENERATE_EXCITED_DENSITY:
        print(f"    - Excited state densities")
    if GENERATE_DENSITY_DIFFERENCE:
        print(f"    - Density differences")

print(f"\nAll output files saved to: {OUTPUT_DIR}/")

print("\n" + "="*70)
print("VISUALIZATION GUIDE")
print("="*70)
print("""
Three types of cube files generated:

1. transition_density_state*.cube
   - Represents the electronic transition between ground and excited state
   - Used for calculating transition dipole moments
   - Visualize with isovalues ±0.002

2. excited_state_density_state*.cube
   - Total electron density in the excited state
   - Compare with ground state density

3. density_difference_state*.cube
   - Change in electron density (excited - ground)
   - Red/positive: electron accumulation
   - Blue/negative: electron depletion
   - Recommended for visualization

VMD visualization:
  vmd output/density_difference_state1.cube
  Graphics > Representations > Drawing Method: Isosurface
  - Rep 1: Isovalue = +0.002, Color = Red (electron gain)
  - Rep 2: Isovalue = -0.002, Color = Blue (electron loss)

Jmol visualization:
  isosurface ID "surf1" cutoff  0.002 output/density_difference_state1.cube
  isosurface ID "surf2" cutoff -0.002 output/density_difference_state1.cube

HOMO/LUMO verification:
  Compare transition_density_state1.cube with HOMO.cube and LUMO.cube
  to verify that S1 corresponds to a HOMO→LUMO transition.

NTO visualization:
  Open output/nto_state_*.molden files in Jmol, Avogadro, or VMD
""")
print("="*70)

print("\n✓ Calculation completed successfully!")
print(f"✓ All files saved to: {OUTPUT_DIR}/\n")
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='DesktopGTX3060', release='5.15.0-161-generic', version='#171-Ubuntu SMP Sat Oct 11 08:17:01 UTC 2025', machine='x86_64')  Threads 12
Python 3.10.12 (main, Aug 15 2025, 14:32:43) [GCC 11.4.0]
numpy 1.26.4  scipy 1.11.4  h5py 3.15.1
Date: Tue Nov 18 12:03:39 2025
PySCF version 2.11.0
PySCF path  /home/indranil/.local/lib/python3.10/site-packages/pyscf/__init__.py
CUDA Environment
    CuPy 13.4.1
    CUDA Path /usr
    CUDA Build Version 12080
    CUDA Driver Version 12090
    CUDA Runtime Version 12080
CUDA toolkit
    cuSolver (11, 7, 4)
    cuBLAS 120900
    cuTENSOR 20301
Device info
    Device name b'NVIDIA GeForce RTX 3060'
    Device global memory 11.63 GB
    CuPy memory fraction 0.9
    Num. Devices 1
GPU4PySCF 1.4.3
GPU4PySCF path  /home/indranil/.local/lib/python3.10/site-packages/gpu4pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 3
[INPUT] num. electrons = 10
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 O      0.000000000000   0.000000000000   0.117300000000 AA    0.000000000000   0.000000000000   0.221664874411 Bohr   0.0
[INPUT]  2 H      0.000000000000   0.757200000000  -0.469200000000 AA    0.000000000000   1.430900621521  -0.886659497646 Bohr   0.0
[INPUT]  3 H      0.000000000000  -0.757200000000  -0.469200000000 AA    0.000000000000  -1.430900621521  -0.886659497646 Bohr   0.0

nuclear repulsion = 9.1895337629349
number of shells = 9
number of NR pGTOs = 30
number of NR cGTOs = 13
basis = 6-31g
ecp = {}
CPU time:         2.23
Number of atoms: 3
Number of electrons: 10
Number of basis functions: 13
Molecular charge: 0
Spin multiplicity (2S+1): 1
Number of unpaired electrons (2S): 0
System type: Closed-shell (singlet)
DFT method: RKS (GPU-accelerated)

======================================================================
GROUND STATE DFT CALCULATION
======================================================================
XC functional: b3lyp
Basis set: 6-31g
Method: RKS (GPU-accelerated)


******** <class 'gpu4pyscf.dft.rks.RKS'> ********
method = RKS
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'gpu4pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
diis_damp = 0
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
max_memory 4000 MB (current use 470 MB)
XC library gpu4pyscf.dft.libxc version 7.0.0 (CUDA)
    unable to decode the reference due to https://github.com/NVIDIA/cuda-python/issues/29
XC functionals = b3lyp
radial grids: 
    Treutler-Ahlrichs [JCP 102, 346 (1995); DOI:10.1063/1.469408] (M4) radial grids
    
becke partition: Becke, JCP 88, 2547 (1988); DOI:10.1063/1.454033
pruning grids: <function nwchem_prune at 0x7f10f0f456c0>
grids dens level: 3
symmetrized grids: False
atomic radii adjust function: <function treutler_atomic_radii_adjust at 0x7f10f0f45510>
small_rho_cutoff = 1e-07
Set gradient conv threshold to 3.16228e-05
tot grids = 33792
init E= -76.3574248014024
  HOMO = -0.427704009706377  LUMO = 0.0225654717088846
cycle= 1 E= -76.2879612696874  delta_E= 0.0695  |g|= 0.709  |ddm|= 1.25
  HOMO = -0.117299342973236  LUMO = 0.0986506250148372
cycle= 2 E= -76.1932085576633  delta_E= 0.0948  |g|= 1.01  |ddm|= 1.22
  HOMO = -0.296531641428354  LUMO = 0.0533365008081806
cycle= 3 E= -76.3849330338669  delta_E= -0.192  |g|= 0.00811  |ddm|= 0.75
  HOMO = -0.291986859123781  LUMO = 0.0575712606514921
cycle= 4 E= -76.38495071337  delta_E= -1.77e-05  |g|= 0.000944  |ddm|= 0.0102
  HOMO = -0.292310544012807  LUMO = 0.0573911917452785
cycle= 5 E= -76.3849509026673  delta_E= -1.89e-07  |g|= 6.89e-05  |ddm|= 0.000924
  HOMO = -0.292334882749227  LUMO = 0.0573914775012575
cycle= 6 E= -76.3849509040949  delta_E= -1.43e-09  |g|= 9.72e-06  |ddm|= 0.00011
  HOMO = -0.292332668156099  LUMO = 0.057391435555194
cycle= 7 E= -76.3849509041147  delta_E= -1.98e-11  |g|= 6.2e-07  |ddm|= 7.73e-06
converged SCF energy = -76.3849509041147
✓ SCF converged
Ground state energy: -76.384951 a.u.

======================================================================
TDDFT CALCULATION
======================================================================
Note: TDDFT inherits XC functional (b3lyp) and basis set (6-31g) from ground state
TDDFT method: TDDFT (RKS-based, GPU-accelerated)
Using full TDDFT - more accurate but slower
Calculating 10 excited states...


******** <class 'gpu4pyscf.tdscf.rks.TDDFT'> for <class 'gpu4pyscf.dft.rks.RKS'> ********
nstates = 10 singlet
deg_eia_thresh = 1.000e-03
wfnsym = None
conv_tol = 1e-05
eigh lindep = 1e-12
eigh level_shift = 0
eigh max_cycle = 100
chkfile = None
max_memory 4000 MB (current use 1070 MB)


Excited State energies (eV)
[ 7.82126554  9.91881649  9.95987075 12.3813972  14.76548306 18.19377751
 27.781912   28.16020602 29.15161266 30.10454211]
✓ TDDFT converged (all states)

** Singlet excitation energies and oscillator strengths **
Excited State   1:      7.82127 eV    158.52 nm  f=0.0115
       5 -> 6        -0.70720
Excited State   2:      9.91882 eV    125.00 nm  f=0.0962
       4 -> 6        -0.70284
Excited State   3:      9.95987 eV    124.48 nm  f=0.0000
       5 -> 7         0.70676
Excited State   4:     12.38140 eV    100.14 nm  f=0.0872
       3 -> 6        -0.11717
       4 -> 7         0.69697
Excited State   5:     14.76548 eV     83.97 nm  f=0.4119
       3 -> 6         0.69694
       4 -> 7         0.11680
Excited State   6:     18.19378 eV     68.15 nm  f=0.2409
       3 -> 7         0.69269
Excited State   7:     27.78191 eV     44.63 nm  f=0.0000
       5 -> 8        -0.70686
Excited State   8:     28.16021 eV     44.03 nm  f=0.0167
       2 -> 6        -0.66081
       5 -> 10        0.24766
Excited State   9:     29.15161 eV     42.53 nm  f=0.0871
       5 -> 9         0.68856
       5 -> 11        0.15976
Excited State  10:     30.10454 eV     41.18 nm  f=0.1482
       2 -> 7        -0.55792
       4 -> 8         0.42668

** Transition electric dipole moments (AU) **
state          X           Y           Z        Dip. S.      Osc.
  1        -0.2453     -0.0000     -0.0000      0.0602      0.0115
  2         0.0000     -0.0000     -0.6291      0.3957      0.0962
  3         0.0000      0.0000      0.0000      0.0000      0.0000
  4        -0.0000      0.5362     -0.0000      0.2875      0.0872
  5         0.0000      1.0670     -0.0000      1.1385      0.4119
  6         0.0000     -0.0000      0.7352      0.5405      0.2409
  7        -0.0000     -0.0000      0.0000      0.0000      0.0000
  8         0.0000      0.0000      0.1554      0.0241      0.0167
  9         0.3492      0.0000     -0.0000      0.1220      0.0871
 10         0.0000      0.4482     -0.0000      0.2009      0.1482

** Transition velocity dipole moments (imaginary part, AU) **
state          X           Y           Z        Dip. S.      Osc.
  1        -0.1323     -0.0000     -0.0000      0.0175      0.0406
  2         0.0000     -0.0000     -0.3050      0.0930      0.1701
  3         0.0000      0.0000      0.0000      0.0000      0.0000
  4        -0.0000      0.2788     -0.0000      0.0777      0.1139
  5        -0.0000      0.5608     -0.0000      0.3145      0.3864
  6         0.0000     -0.0000      0.4643      0.2156      0.2150
  7         0.0000     -0.0000      0.0000      0.0000      0.0000
  8         0.0000      0.0000      0.1627      0.0265      0.0170
  9         0.2087      0.0000     -0.0000      0.0435      0.0271
 10        -0.0000      0.4132     -0.0000      0.1707      0.1029

** Transition magnetic dipole moments (imaginary part, AU) **
state          X           Y           Z
  1        -0.0000     -0.2368      0.0000
  2        -0.0000      0.0000      0.0000
  3         0.0000     -0.0000     -0.3479
  4         0.4097     -0.0000      0.0000
  5        -0.0816     -0.0000      0.0000
  6        -0.0000      0.0000      0.0000
  7        -0.0000     -0.0000      0.3270
  8         0.0000      0.0000      0.0000
  9        -0.0000     -0.1809      0.0000
 10         0.4615      0.0000      0.0000

======================================================================
EXCITED STATE ENERGIES
======================================================================
State 1: 0.287426 a.u. = 7.821 eV
State 2: 0.364510 a.u. = 9.919 eV
State 3: 0.366019 a.u. = 9.960 eV
State 4: 0.455008 a.u. = 12.381 eV
State 5: 0.542621 a.u. = 14.765 eV
State 6: 0.668609 a.u. = 18.194 eV
State 7: 1.020966 a.u. = 27.782 eV
State 8: 1.034868 a.u. = 28.160 eV
State 9: 1.071302 a.u. = 29.151 eV
State 10: 1.106322 a.u. = 30.104 eV
======================================================================

======================================================================
TRANSITION DIPOLE MOMENTS
======================================================================

Transition dipole moments (a.u.):
State    μ_x          μ_y          μ_z          |μ|          f           
----------------------------------------------------------------------
1          -0.122665   -0.000000   -0.000000    0.122665    0.002883
2           0.000000   -0.000000   -0.314529    0.314529    0.024040
3           0.000000    0.000000    0.000000    0.000000    0.000000
4          -0.000000    0.268094   -0.000000    0.268094    0.021802
5           0.000000    0.533510   -0.000000    0.533510    0.102965
6           0.000000   -0.000000    0.367588    0.367588    0.060229
7          -0.000000   -0.000000    0.000000    0.000000    0.000000
8           0.000000    0.000000    0.077688    0.077688    0.004164
9           0.174618    0.000000   -0.000000    0.174618    0.021777
10          0.000000    0.224114   -0.000000    0.224114    0.037045
======================================================================

======================================================================
NATURAL TRANSITION ORBITAL ANALYSIS
======================================================================

State 1 (7.821 eV):
State 1: 7.82127 eV  NTO largest component 0.9998829284374544
    occ-NTO: 1.000000 (MO #5)
    vir-NTO: 0.999752 (MO #6)
  NTO orbitals saved to: output_gpu/nto_state_1.molden

State 2 (9.919 eV):
State 2: 9.91882 eV  NTO largest component 0.9865289700955497
    occ-NTO: 0.999698 (MO #4)
    vir-NTO: 0.999874 (MO #6)
  NTO orbitals saved to: output_gpu/nto_state_2.molden

State 3 (9.960 eV):
State 3: 9.95987 eV  NTO largest component 0.9999917137751234
    occ-NTO: 1.000000 (MO #5)
    vir-NTO: 0.999431 (MO #7)
  NTO orbitals saved to: output_gpu/nto_state_3.molden
======================================================================

======================================================================
GRID PARAMETERS
======================================================================
Using box dimensions with margin: 4.0 Å
Grid spacing: 0.2 Å
Calculated grid resolution: 40 × 48 × 43
Total grid points: 82,560
Box size: [8.         9.5143994  8.58649977] Å
======================================================================

======================================================================
GENERATING HOMO/LUMO CUBE FILES
======================================================================
HOMO index: 4
LUMO index: 5
HOMO energy: -7.955 eV
LUMO energy: 1.562 eV
HOMO-LUMO gap: 9.516 eV

  ✓ HOMO orbital: output_gpu/HOMO.cube
  ✓ LUMO orbital: output_gpu/LUMO.cube
  ✓ HOMO-1 orbital: output_gpu/HOMO-1.cube
  ✓ LUMO+1 orbital: output_gpu/LUMO+1.cube

Verification tip:
For the first excited state (S1), check if the transition density
resembles a HOMO→LUMO transition by comparing:
  - transition_density_state1.cube
  - HOMO.cube (electron depletion)
  - LUMO.cube (electron accumulation)

----------------------------------------------------------------------
ANALYTICAL VERIFICATION: HOMO→LUMO Transition Density
----------------------------------------------------------------------
  ✓ Analytical HOMO→LUMO transition: output_gpu/transition_HOMO_LUMO_analytical.cube

To verify S1 is a HOMO→LUMO transition, compare:
  1. output_gpu/transition_density_state1.cube
  2. output_gpu/transition_HOMO_LUMO_analytical.cube

They should be very similar if S1 is dominated by HOMO→LUMO excitation.
You can calculate the overlap/similarity in VMD or by visual inspection.
======================================================================

======================================================================
GENERATING EXCITED STATE CUBE FILES
======================================================================
Generating cube files for states: [1, 2, 3]
Grid resolution: 40 × 48 × 43

State 1: 7.821 eV
  ✓ Transition density: output_gpu/transition_density_state1.cube
  ✓ Excited state density: output_gpu/excited_state_density_state1.cube
  ✓ Density difference: output_gpu/density_difference_state1.cube

  ------------------------------------------------------------------
  QUANTITATIVE VERIFICATION: S1 vs HOMO→LUMO
  ------------------------------------------------------------------
  Similarity (cosine): -0.9997
  HOMO→LUMO weight: 0.9992 (99.9%)
  HOMO→LUMO amplitude: 0.9821
  ⚠ S1 is NOT a pure HOMO→LUMO transition (multi-configurational)
  ------------------------------------------------------------------

State 2: 9.919 eV
  ✓ Transition density: output_gpu/transition_density_state2.cube
  ✓ Excited state density: output_gpu/excited_state_density_state2.cube
  ✓ Density difference: output_gpu/density_difference_state2.cube

State 3: 9.960 eV
  ✓ Transition density: output_gpu/transition_density_state3.cube
  ✓ Excited state density: output_gpu/excited_state_density_state3.cube
  ✓ Density difference: output_gpu/density_difference_state3.cube
======================================================================

======================================================================
CALCULATION SUMMARY
======================================================================

Molecule: H2O test molecule
Basis set: 6-31g
Number of atoms: 3
Number of electrons: 10
Number of basis functions: 13
Molecular charge: 0
Spin multiplicity: 1 (closed-shell)

Computational settings:
  DFT method: RKS
  XC functional: b3lyp
  Parallel threads: auto-detected
  TDDFT method: Full TDDFT (not TDA)
  Number of excited states calculated: 10

Grid settings:
  Mode: Box dimensions
  Margin: 4.0 Å, Spacing: 0.2 Å
  Grid: 40 × 48 × 43 = 82,560 points

Output files generated:
  ✓ HOMO/LUMO orbitals (in output_gpu/)
  ✓ NTO analysis for 3 state(s)
  ✓ Cube files for 3 state(s):
    - Transition density matrices
    - Excited state densities
    - Density differences

All output files saved to: output_gpu/

======================================================================
VISUALIZATION GUIDE
======================================================================

Three types of cube files generated:

1. transition_density_state*.cube
   - Represents the electronic transition between ground and excited state
   - Used for calculating transition dipole moments
   - Visualize with isovalues ±0.002

2. excited_state_density_state*.cube
   - Total electron density in the excited state
   - Compare with ground state density

3. density_difference_state*.cube
   - Change in electron density (excited - ground)
   - Red/positive: electron accumulation
   - Blue/negative: electron depletion
   - Recommended for visualization

VMD visualization:
  vmd output/density_difference_state1.cube
  Graphics > Representations > Drawing Method: Isosurface
  - Rep 1: Isovalue = +0.002, Color = Red (electron gain)
  - Rep 2: Isovalue = -0.002, Color = Blue (electron loss)

Jmol visualization:
  isosurface ID "surf1" cutoff  0.002 output/density_difference_state1.cube
  isosurface ID "surf2" cutoff -0.002 output/density_difference_state1.cube

HOMO/LUMO verification:
  Compare transition_density_state1.cube with HOMO.cube and LUMO.cube
  to verify that S1 corresponds to a HOMO→LUMO transition.

NTO visualization:
  Open output/nto_state_*.molden files in Jmol, Avogadro, or VMD

======================================================================

✓ Calculation completed successfully!
✓ All files saved to: output_gpu/

