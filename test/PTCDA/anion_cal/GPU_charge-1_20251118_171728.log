Created output directory: output_gpu_charge-1

Parallel computation enabled: 12 threads (auto-detected)

======================================================================
MOLECULE SETUP
======================================================================
Loading molecule from: PTCDA_clean.xyz
Basis set: 6-31g
Charge: -1
#INFO: **** input file is /home/indranil/Documents/Secondment/test/PTCDA/anion_cal/tdm_calc_accurate_GPU.py ****
#!/usr/bin/env python
'''
GPU-Accelerated Transition Density Matrix Calculation
Based on official PySCF examples with GPU4PySCF support

Features:
- GPU acceleration for DFT and TDDFT (B3LYP, UKS fully supported)
- Parallel calculation support
- Configurable grid size and box dimensions
- Selective state output
- HOMO/LUMO cube file generation

Requirements:
- pip install gpu4pyscf-cuda12x
- pip install cutensor-cu12 (optional, for 10-20% better performance)
'''

from pyscf import gto, lib
from pyscf.tools import cubegen, molden
from gpu4pyscf import dft
from gpu4pyscf.tdscf import rks as gpu_tdrks, uks as gpu_tduks
import numpy as np
from functools import reduce
import os

# ============================================================================
# CONFIGURATION SECTION - MODIFY THESE SETTINGS
# ============================================================================

# --- Parallel Calculation Settings ---
# Note: GPU handles DFT/TDDFT parallelization automatically
ENABLE_PARALLEL = True  # Enable/disable parallel computation for CPU operations
NUM_THREADS = 0

# --- Molecule Selection ---
USE_XYZ = True
# XYZ_FILE = 'H2O.xyz'  # Path to XYZ file
XYZ_FILE = 'PTCDA_clean.xyz'
BASIS_SET = '6-31g'

# --- Charge and Spin Settings ---
CHARGE = -1
SPIN = None
# Note: Spin is auto-calculated from electron count if set to None
# For charged systems: cation (+1) typically has spin=2 (doublet), anion (-1) has spin=2 (doublet)
# Neutral even-electron systems typically have spin=1 (singlet)

# --- DFT/TDDFT Settings ---
# Note: TDDFT uses the same basis set and XC functional as ground state DFT
XC_FUNCTIONAL = 'b3lyp'
# Common options:
#   'b3lyp'    - B3LYP (hybrid, good general purpose)
#   'pbe0'     - PBE0 (hybrid, good for excited states)
#   'cam-b3lyp' - CAM-B3LYP (range-separated, good for charge transfer)
#   'wb97x-d'  - ωB97X-D (range-separated with dispersion)
#   'pbe'      - PBE (GGA, faster but less accurate)
#   'blyp'     - BLYP (GGA)

NUM_EXCITED_STATES = 10

# --- TDDFT Method Selection ---
USE_TDA = False
# TDA (Tamm-Dancoff Approximation) is recommended for large systems or initial testing
# For charged/open-shell systems, TDDFT automatically uses appropriate method
# Closed-shell (spin=1): Uses RKS/TDDFT or RKS/TDA
# Open-shell (spin>1): Uses UKS/TDDFT or UKS/TDA

# --- Output Selection ---
# STATES_TO_OUTPUT: Which states to generate CUBE FILES for (0-indexed)
# Cube files are large (~150-500 MB per state), so be selective
# Examples:
#   [0, 1, 2] - First three states
#   [0, 4, 9] - States 1, 5, and 10
#   range(5) - First five states
STATES_TO_OUTPUT = [0, 1, 2]

# --- Cube File Generation Options ---
GENERATE_TRANSITION_DENSITY = True
GENERATE_EXCITED_DENSITY = True
GENERATE_DENSITY_DIFFERENCE = True
GENERATE_HOMO_LUMO = True

# --- Grid Settings ---
# Option 1: Use grid resolution (number of points per axis)
USE_GRID_RESOLUTION = False
GRID_RESOLUTION = [80, 80, 80]

# Option 2: Use box dimensions (in Angstrom) - only used if USE_GRID_RESOLUTION = False
BOX_MARGIN = 4.0
GRID_SPACING = 0.2

# --- NTO Analysis ---
# NTO_STATES: Which states to perform NTO ANALYSIS for (0-indexed)
# NTO molden files are small (~5 MB per state), so you can analyze more states
# This is INDEPENDENT of STATES_TO_OUTPUT - you can have different lists
# Example: Generate cube files for [0,1] but NTO analysis for [0,1,2,3,4]
ENABLE_NTO_ANALYSIS = True
NTO_STATES = [0, 1, 2]

# --- Transition Contribution Analysis ---
# Analyze which orbital pairs (i→a) contribute to each excited state
# Shows percentage contribution and generates cube files for dominant pairs
ENABLE_CONTRIBUTION_ANALYSIS = True
CONTRIBUTION_STATES = [0, 1, 2]
CONTRIBUTION_THRESHOLD = 0.01
TOP_N_CONTRIBUTIONS = 10
GENERATE_PAIR_CUBES = True
MAX_PAIRS_PER_STATE = 3
PAIR_CONTRIBUTION_CUTOFF = 0.05

# --- Output Directory ---
OUTPUT_DIR = 'output_gpu_charge-1'

# ============================================================================
# END OF CONFIGURATION
# ============================================================================

# ============================================================================
# SETUP AND INITIALIZATION
# ============================================================================

# Create output directory
if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)
    print(f"Created output directory: {OUTPUT_DIR}")

# Setup parallel computation
if ENABLE_PARALLEL:
    if NUM_THREADS > 0:
        lib.num_threads(NUM_THREADS)
        print(f"\nParallel computation enabled: {NUM_THREADS} threads")
    else:
        # Auto-detect number of cores
        import multiprocessing
        num_cores = multiprocessing.cpu_count()
        lib.num_threads(num_cores)
        print(f"\nParallel computation enabled: {num_cores} threads (auto-detected)")
else:
    lib.num_threads(1)
    print("\nParallel computation disabled: using 1 thread")

# ============================================================================
# 1. MOLECULE DEFINITION
# ============================================================================

def create_h2o_molecule():
    """Create H2O test molecule"""
    mol = gto.M(
        atom = '''
        O  0.0000  0.0000  0.1173
        H  0.0000  0.7572 -0.4692
        H  0.0000 -0.7572 -0.4692
        ''',
        basis = BASIS_SET,
        verbose = 4
    )
    return mol

def calculate_spin_multiplicity(n_electrons, charge):
    """
    Calculate spin multiplicity (2S+1) from electron count.
    
    Args:
        n_electrons: Total number of electrons in neutral molecule
        charge: Molecular charge
    
    Returns:
        spin: Spin multiplicity (2S+1)
    """
    # Adjust electron count for charge
    n_elec = n_electrons - charge
    
    # For even number of electrons: singlet (spin=1)
    # For odd number of electrons: doublet (spin=2)
    if n_elec % 2 == 0:
        spin = 1  # Singlet (closed-shell)
    else:
        spin = 2  # Doublet (open-shell)
    
    return spin

def create_molecule_from_xyz(xyz_file, basis, charge=0, spin=None):
    """
    Load molecule from XYZ file with charge and spin.
    
    Args:
        xyz_file: Path to XYZ file
        basis: Basis set
        charge: Molecular charge
        spin: Spin multiplicity (None = auto-calculate)
    """
    # First, create molecule to get electron count
    mol_temp = gto.M(atom=xyz_file, basis=basis, charge=0, spin=0, verbose=0)
    n_electrons = mol_temp.nelectron
    
    # Calculate spin if not provided
    if spin is None:
        spin = calculate_spin_multiplicity(n_electrons, charge)
    
    # Create final molecule with charge and spin
    mol = gto.M(
        atom = xyz_file,
        basis = basis,
        charge = charge,
        spin = spin - 1,  # PySCF uses 2S (number of unpaired electrons), not 2S+1
        verbose = 4
    )
    
    return mol, spin

print("\n" + "="*70)
print("MOLECULE SETUP")
print("="*70)

if USE_XYZ:
    print(f"Loading molecule from: {XYZ_FILE}")
    print(f"Basis set: {BASIS_SET}")
    print(f"Charge: {CHARGE}")
    mol, calculated_spin = create_molecule_from_xyz(XYZ_FILE, BASIS_SET, CHARGE, SPIN)
    actual_spin = calculated_spin
else:
    print("Using H2O test molecule")
    print(f"Basis set: {BASIS_SET}")
    mol = create_h2o_molecule()
    actual_spin = 1  # H2O is singlet

print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity (2S+1): {actual_spin}")
print(f"Number of unpaired electrons (2S): {mol.spin}")

if actual_spin == 1:
    print("System type: Closed-shell (singlet)")
    dft_method = "RKS"
else:
    print(f"System type: Open-shell ({['singlet', 'doublet', 'triplet', 'quartet', 'quintet'][actual_spin-1] if actual_spin <= 5 else f'spin={actual_spin}'})")
    dft_method = "UKS"

print(f"DFT method: {dft_method} (GPU-accelerated)")

# ============================================================================
# 2. GROUND STATE DFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("GROUND STATE DFT CALCULATION")
print("="*70)
print(f"XC functional: {XC_FUNCTIONAL}")
print(f"Basis set: {BASIS_SET}")
print(f"Method: {dft_method} (GPU-accelerated)")

# Select RKS (closed-shell) or UKS (open-shell) based on spin
if actual_spin == 1:
    mf = dft.RKS(mol)
else:
    mf = dft.UKS(mol)

mf.xc = XC_FUNCTIONAL
mf.kernel()

if not mf.converged:
    print("WARNING: SCF did not converge!")
    print("Try: 1) Different initial guess, 2) Level shifting, 3) DIIS settings")
else:
    print("✓ SCF converged")

print(f"Ground state energy: {mf.e_tot:.6f} a.u.")

# ============================================================================
# 3. TDDFT CALCULATION
# ============================================================================

print("\n" + "="*70)
print("TDDFT CALCULATION")
print("="*70)
print(f"Note: TDDFT inherits XC functional ({XC_FUNCTIONAL}) and basis set ({BASIS_SET}) from ground state")
method_name = 'TDA' if USE_TDA else 'TDDFT'
spin_type = 'RKS' if actual_spin == 1 else 'UKS'
print(f"TDDFT method: {method_name} ({spin_type}-based, GPU-accelerated)")

# Select TDA or full TDDFT
# Use gpu4pyscf.tdscf module (RKS or UKS based on spin)
if actual_spin == 1:
    # Closed-shell: use gpu4pyscf.tdscf.rks
    if USE_TDA:
        td = gpu_tdrks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tdrks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
else:
    # Open-shell: use gpu4pyscf.tdscf.uks
    if USE_TDA:
        td = gpu_tduks.TDA(mf)  # Faster, ~95% accuracy
        print("Using TDA (Tamm-Dancoff Approximation) - faster calculation")
    else:
        td = gpu_tduks.TDDFT(mf)  # More accurate
        print("Using full TDDFT - more accurate but slower")
td.nstates = NUM_EXCITED_STATES
print(f"Calculating {NUM_EXCITED_STATES} excited states...")
td.kernel()

# Handle both RKS (scalar) and UKS (array) convergence
if hasattr(td.converged, '__len__'):  # UKS: array
    if not td.converged.all():
        print(f"WARNING: TDDFT did not converge for some states!")
        print(f"  Converged states: {td.converged.sum()}/{len(td.converged)}")
    else:
        print("✓ TDDFT converged (all states)")
else:  # RKS: scalar
    if not td.converged:
        print("WARNING: TDDFT did not converge!")
    else:
        print("✓ TDDFT converged")

td.analyze()  # Print detailed analysis

# Print excitation energies
print("\n" + "="*70)
print("EXCITED STATE ENERGIES")
print("="*70)
for i, energy in enumerate(td.e):
    print(f"State {i+1}: {energy:.6f} a.u. = {energy*27.211:.3f} eV")
print("="*70)

# ============================================================================
# 4. TRANSITION DIPOLE MOMENTS
# ============================================================================

print("\n" + "="*70)
print("TRANSITION DIPOLE MOMENTS")
print("="*70)

# Set gauge origin to nuclear charge center
charges = mol.atom_charges()
coords = mol.atom_coords()  # in a.u.
nuc_charge_center = np.einsum('z,zx->x', charges, coords) / charges.sum()
mol.set_common_orig_(nuc_charge_center)

# Calculate dipole integrals
dip_ints = mol.intor('cint1e_r_sph', comp=3)  # x, y, z components

def calculate_transition_dipole(td, state_id):
    """
    Calculate transition dipole moment for a given excited state.
    Based on PySCF example: examples/1-advanced/030-transition_dipole.py
    
    Handles both RKS (closed-shell) and UKS (open-shell) cases.
    For GPU4PySCF, converts CuPy arrays to NumPy arrays.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    tdm : ndarray, shape (3,)
        Transition dipole moment [x, y, z] in a.u.
    """
    # Get TDDFT amplitudes (X and Y vectors)
    X, Y = td.xy[state_id]
    
    # Get MO coefficients and occupations
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    
    # Check if UKS by checking if X is a tuple (more reliable than mo_coeff)
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS: mo_coeff and mo_occ are tuples (alpha, beta)
        # For UKS, X and Y are also tuples: ((Xa, Xb), (Ya, Yb))
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        # Xa and Xb are already separated, just need to get dimensions
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Transition density matrices for alpha and beta
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        # Total transition density (alpha + beta)
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
        
    else:
        # RKS: mo_coeff and mo_occ are arrays
        # Convert CuPy to NumPy if needed
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        # Transition density in MO basis
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        
        # Transform to AO basis
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    # Calculate transition dipole: μ = Tr(μ_op * T)
    tdm = np.einsum('xij,ji->x', dip_ints, t_dm1_ao)
    
    return tdm

# Calculate and print transition dipoles for all states
print("\nTransition dipole moments (a.u.):")
print(f"{'State':<8} {'μ_x':<12} {'μ_y':<12} {'μ_z':<12} {'|μ|':<12} {'f':<12}")
print("-" * 70)

for i in range(td.nstates):
    tdm = calculate_transition_dipole(td, i)
    tdm_magnitude = np.linalg.norm(tdm)
    
    # Oscillator strength: f = (2/3) * ω * |μ|^2
    # where ω is excitation energy in a.u.
    omega = td.e[i]
    osc_strength = (2.0/3.0) * omega * tdm_magnitude**2
    
    print(f"{i+1:<8} {tdm[0]:>11.6f} {tdm[1]:>11.6f} {tdm[2]:>11.6f} "
          f"{tdm_magnitude:>11.6f} {osc_strength:>11.6f}")

print("="*70)

# ============================================================================
# 5. TRANSITION DENSITY MATRICES
# ============================================================================

def calculate_transition_density_matrix(td, state_id):
    """
    Calculate transition density matrix between ground and excited state.
    This is the proper transition density for visualization.
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    t_dm1_ao : ndarray
        Transition density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mo_coeff = td._scf.mo_coeff
    mo_occ = td._scf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        mo_coeff_a, mo_coeff_b = mo_coeff
        mo_occ_a, mo_occ_b = mo_occ
        Xa, Xb = X
        Ya, Yb = Y
        
        # Convert CuPy to NumPy
        if hasattr(mo_coeff_a, 'get'):
            mo_coeff_a = mo_coeff_a.get()
            mo_coeff_b = mo_coeff_b.get()
            mo_occ_a = mo_occ_a.get()
            mo_occ_b = mo_occ_b.get()
        if hasattr(Xa, 'get'):
            Xa = Xa.get()
            Xb = Xb.get()
            Ya = Ya.get()
            Yb = Yb.get()
        
        nocc_a = Xa.shape[0]
        nvir_a = Xa.shape[1]
        nocc_b = Xb.shape[0]
        nvir_b = Xb.shape[1]
        nmo_a = mo_coeff_a.shape[1]
        nmo_b = mo_coeff_b.shape[1]
        
        # Alpha
        t_dm1_mo_a = np.zeros((nmo_a, nmo_a))
        t_dm1_mo_a[:nocc_a, nocc_a:] = Xa + Ya
        t_dm1_mo_a[nocc_a:, :nocc_a] = (Xa + Ya).T
        t_dm1_ao_a = reduce(np.dot, (mo_coeff_a, t_dm1_mo_a, mo_coeff_a.T))
        
        # Beta
        t_dm1_mo_b = np.zeros((nmo_b, nmo_b))
        t_dm1_mo_b[:nocc_b, nocc_b:] = Xb + Yb
        t_dm1_mo_b[nocc_b:, :nocc_b] = (Xb + Yb).T
        t_dm1_ao_b = reduce(np.dot, (mo_coeff_b, t_dm1_mo_b, mo_coeff_b.T))
        
        t_dm1_ao = t_dm1_ao_a + t_dm1_ao_b
    else:
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        orbo = mo_coeff[:, mo_occ > 0]
        orbv = mo_coeff[:, mo_occ == 0]
        nocc = orbo.shape[1]
        nvir = orbv.shape[1]
        
        t_dm1_mo = np.zeros((mo_coeff.shape[1], mo_coeff.shape[1]))
        t_dm1_mo[:nocc, nocc:] = (X + Y).reshape(nocc, nvir)
        t_dm1_mo[nocc:, :nocc] = (X + Y).reshape(nocc, nvir).T
        t_dm1_ao = reduce(np.dot, (mo_coeff, t_dm1_mo, mo_coeff.T))
    
    return t_dm1_ao

def calculate_excited_state_density(td, state_id):
    """
    Calculate excited state density matrix.
    Based on PySCF examples/tddft/22-density.py
    Handles both RKS and UKS, converts CuPy to NumPy.
    
    Parameters:
    -----------
    td : TDDFT object
    state_id : int (0-indexed)
    
    Returns:
    --------
    dm_excited : ndarray
        Excited state density matrix in AO basis
    """
    X, Y = td.xy[state_id]
    mf = td._scf
    mo_coeff = mf.mo_coeff
    mo_occ = mf.mo_occ
    is_uks = isinstance(X, tuple)
    
    if is_uks:
        # UKS case - simplified approach: use transition density
        # For visualization, transition density is more meaningful
        return calculate_transition_density_matrix(td, state_id)
    else:
        # RKS case
        # Convert CuPy to NumPy
        if hasattr(mo_coeff, 'get'):
            mo_coeff = mo_coeff.get()
            mo_occ = mo_occ.get()
        if hasattr(X, 'get'):
            X = X.get()
            Y = Y.get()
        
        nocc = X.shape[0]
        
        # Density matrix changes in MO basis
        dm_oo = -np.einsum('ia,ka->ik', X.conj(), X)
        dm_oo -= np.einsum('ia,ka->ik', Y.conj(), Y)
        
        dm_vv = np.einsum('ia,ic->ac', X, X.conj())
        dm_vv += np.einsum('ia,ic->ac', Y, Y.conj())
        
        # Start with ground state density in MO basis
        dm = np.diag(mo_occ)
        
        # Add TDDFT contribution
        dm[:nocc, :nocc] += dm_oo * 2
        dm[nocc:, nocc:] += dm_vv * 2
        
        # Transform to AO basis
        dm_excited = np.einsum('pi,ij,qj->pq', mo_coeff, dm, mo_coeff.conj())
    
    return dm_excited

# ============================================================================
# 5A. TRANSITION CONTRIBUTION ANALYSIS FUNCTIONS
# ============================================================================

def get_orbital_labels(mf):
    """Get orbital labels (HOMO-n, LUMO+n) for RKS and UKS."""
    mo_occ = mf.mo_occ
    mo_coeff = mf.mo_coeff
    
    # Handle UKS (use alpha spin) and CuPy arrays
    if isinstance(mo_occ, tuple):
        mo_occ = mo_occ[0]
    if isinstance(mo_coeff, tuple):
        mo_coeff = mo_coeff[0]
    if hasattr(mo_occ, 'get'):
        mo_occ = mo_occ.get()
    if hasattr(mo_coeff, 'get'):
        mo_coeff = mo_coeff.get()
    
    # Get number of orbitals from mo_coeff shape
    nmo = mo_coeff.shape[1]
    homo_idx = np.where(mo_occ > 0)[0][-1]
    
    labels = []
    for i in range(nmo):
        if i <= homo_idx:
            offset = homo_idx - i
            labels.append('HOMO' if offset == 0 else f'HOMO-{offset}')
        else:
            offset = i - homo_idx - 1
            labels.append('LUMO' if offset == 0 else f'LUMO+{offset}')
    
    return labels, homo_idx

def analyze_transition_contributions(td, state_id, mf, threshold=0.01, top_n=10):
    """
    Analyze orbital pair contributions to a specific excited state.
    Handles both RKS and UKS systems, and CuPy arrays.
    
    Returns:
        contributions: list of (occ_idx, vir_idx, weight, label) sorted by weight
        total_weight: sum of all weights
    """
    X, Y = td.xy[state_id]
    
    # Handle UKS: X and Y are tuples (Xa, Xb), (Ya, Yb)
    # For simplicity, analyze alpha spin (dominant for most cases)
    if isinstance(X, tuple):
        X, _ = X
        Y, _ = Y
    
    # Convert CuPy to NumPy if needed
    if hasattr(X, 'get'):
        X = X.get()
    if hasattr(Y, 'get'):
        Y = Y.get()
    
    nocc, nvir = X.shape
    
    # For full TDDFT, the contribution is from (X + Y)
    amplitudes = X + Y
    
    # Calculate weights (squared amplitudes)
    weights = amplitudes ** 2
    
    # Get orbital labels
    labels, homo_idx = get_orbital_labels(mf)
    
    # Collect all contributions
    contributions = []
    for i in range(nocc):
        for a in range(nvir):
            weight = weights[i, a]
            if weight > threshold:
                occ_idx = i
                vir_idx = nocc + a
                occ_label = labels[occ_idx]
                vir_label = labels[vir_idx]
                transition_label = f"{occ_label} → {vir_label}"
                contributions.append((occ_idx, vir_idx, weight, transition_label))
    
    # Sort by weight (descending)
    contributions.sort(key=lambda x: x[2], reverse=True)
    
    # Normalize weights to sum to 1
    total_weight = sum(c[2] for c in contributions)
    if total_weight > 0:
        contributions = [(occ, vir, w/total_weight, label) 
                         for occ, vir, w, label in contributions]
    
    # Return top N
    return contributions[:top_n], total_weight

def calculate_pair_transition_density(mf, occ_idx, vir_idx):
    """
    Calculate transition density matrix for a single orbital pair i→a.
    Handles both RKS and UKS (uses alpha spin for UKS), and CuPy arrays.
    
    T_μν = C_μ^i × C_ν^a + C_μ^a × C_ν^i
    
    Returns NumPy array in AO basis.
    """
    mo_coeff = mf.mo_coeff
    
    # Handle UKS (use alpha spin)
    if isinstance(mo_coeff, tuple):
        mo_coeff_alpha = mo_coeff[0]
    else:
        mo_coeff_alpha = mo_coeff
    
    # Convert CuPy to NumPy if needed
    if hasattr(mo_coeff_alpha, 'get'):
        mo_coeff_alpha = mo_coeff_alpha.get()
    
    # Ensure we have NumPy array
    mo_coeff_alpha = np.asarray(mo_coeff_alpha)
    
    # Extract specific orbitals
    occ_mo = mo_coeff_alpha[:, occ_idx]
    vir_mo = mo_coeff_alpha[:, vir_idx]
    
    # Transition density matrix for this pair in AO basis
    # T_μν = C_μ^i × C_ν^a + C_μ^a × C_ν^i (symmetric)
    t_dm = np.outer(occ_mo, vir_mo) + np.outer(vir_mo, occ_mo)
    
    # Ensure it's a proper NumPy array with correct dtype
    t_dm = np.asarray(t_dm, dtype=np.float64)
    
    return t_dm

# ============================================================================
# 6. NATURAL TRANSITION ORBITALS (NTO) ANALYSIS
# ============================================================================

if ENABLE_NTO_ANALYSIS:
    print("\n" + "="*70)
    print("NATURAL TRANSITION ORBITAL ANALYSIS")
    print("="*70)
    
    # Filter valid NTO states
    valid_nto_states = [s for s in NTO_STATES if s < td.nstates]
    
    if not valid_nto_states:
        print("No valid NTO states selected.")
    else:
        for i in valid_nto_states:
            print(f"\nState {i+1} ({td.e[i]*27.211:.3f} eV):")
            weights, nto_coeff = td.get_nto(state=i+1, verbose=4)
            
            # Save NTO orbitals to molden format for visualization
            # For UKS, nto_coeff is a tuple (alpha, beta)
            if isinstance(nto_coeff, tuple):
                # Save alpha NTOs
                molden_file_a = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_alpha.molden')
                molden.from_mo(mol, molden_file_a, nto_coeff[0])
                print(f"  Alpha NTO orbitals saved to: {molden_file_a}")
                
                # Save beta NTOs
                molden_file_b = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}_beta.molden')
                molden.from_mo(mol, molden_file_b, nto_coeff[1])
                print(f"  Beta NTO orbitals saved to: {molden_file_b}")
            else:
                # RKS case
                molden_file = os.path.join(OUTPUT_DIR, f'nto_state_{i+1}.molden')
                molden.from_mo(mol, molden_file, nto_coeff)
                print(f"  NTO orbitals saved to: {molden_file}")
    
    print("="*70)
else:
    print("\nNTO analysis disabled.")

# ============================================================================
# 6A. TRANSITION CONTRIBUTION ANALYSIS
# ============================================================================

if ENABLE_CONTRIBUTION_ANALYSIS:
    print("\n" + "="*70)
    print("TRANSITION CONTRIBUTION ANALYSIS")
    print("="*70)
    print("Analyzing orbital pair contributions to excited states...")
    
    # Filter valid states
    valid_contrib_states = [s for s in CONTRIBUTION_STATES if s < td.nstates]
    
    if not valid_contrib_states:
        print("No valid states selected for contribution analysis.")
    else:
        # Store all contributions for summary
        all_contributions = {}
        
        for state_id in valid_contrib_states:
            excitation_energy = td.e[state_id] * 27.211  # Convert to eV
            
            # Analyze contributions
            contributions, total_weight = analyze_transition_contributions(
                td, state_id, mf,
                threshold=CONTRIBUTION_THRESHOLD,
                top_n=TOP_N_CONTRIBUTIONS
            )
            
            all_contributions[state_id] = (contributions, total_weight)
            
            # Print contribution table
            print(f"\n{'='*70}")
            print(f"STATE {state_id+1}: {excitation_energy:.4f} eV")
            print(f"{'='*70}")
            print(f"{'Rank':<6} {'Transition':<20} {'Weight':<12} {'Percentage':<12} {'Cumulative':<12}")
            print(f"{'-'*70}")
            
            cumulative = 0.0
            for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
                cumulative += weight
                print(f"{rank:<6} {label:<20} {weight:<12.6f} {weight*100:<12.2f}% {cumulative*100:<12.2f}%")
            
            print(f"{'-'*70}")
            print(f"Total weight analyzed: {total_weight:.6f}")
        
        # Save contribution tables to file
        table_file = os.path.join(OUTPUT_DIR, 'contribution_tables.txt')
        with open(table_file, 'w') as f:
            f.write("="*70 + "\n")
            f.write("ORBITAL PAIR CONTRIBUTIONS TO EXCITED STATES\n")
            f.write("="*70 + "\n\n")
            
            for state_id in valid_contrib_states:
                contributions, total_weight = all_contributions[state_id]
                excitation_energy = td.e[state_id] * 27.211
                
                f.write(f"\n{'='*70}\n")
                f.write(f"STATE {state_id+1}: {excitation_energy:.4f} eV\n")
                f.write(f"{'='*70}\n")
                f.write(f"{'Rank':<6} {'Transition':<20} {'Weight':<12} {'Percentage':<12} {'Cumulative':<12}\n")
                f.write(f"{'-'*70}\n")
                
                cumulative = 0.0
                for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
                    cumulative += weight
                    f.write(f"{rank:<6} {label:<20} {weight:<12.6f} {weight*100:<12.2f}% {cumulative*100:<12.2f}%\n")
                
                f.write(f"{'-'*70}\n")
                f.write(f"Total weight analyzed: {total_weight:.6f}\n")
                f.write(f"{'='*70}\n\n")
        
        print(f"\n✓ Contribution tables saved to: {table_file}")
        
        # Generate cube files for dominant orbital pairs
        if GENERATE_PAIR_CUBES:
            print(f"\n{'='*70}")
            print("GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES")
            print(f"{'='*70}")
            print("Note: Cube files will be generated after grid parameters are calculated")
            print("      (see CUBE FILE GENERATION section below)")
    
    print("="*70)
else:
    print("\nTransition contribution analysis disabled.")

# ============================================================================
# 7. CALCULATE GRID PARAMETERS
# ============================================================================

def calculate_grid_parameters(mol, use_resolution=True, resolution=None, 
                             box_margin=4.0, grid_spacing=0.2):
    """
    Calculate grid parameters for cube file generation.
    
    Parameters:
    -----------
    mol : Mole object
    use_resolution : bool
        If True, use fixed resolution. If False, calculate from box dimensions.
    resolution : list [nx, ny, nz]
        Grid resolution (number of points per axis)
    box_margin : float
        Margin around molecule in Angstrom
    grid_spacing : float
        Grid spacing in Angstrom
    
    Returns:
    --------
    nx, ny, nz : int
        Grid resolution
    box_info : dict
        Box dimension information
    """
    # Get molecular coordinates in Angstrom
    coords = mol.atom_coords() * 0.529177  # Bohr to Angstrom
    
    # Calculate bounding box
    min_coords = coords.min(axis=0)
    max_coords = coords.max(axis=0)
    mol_size = max_coords - min_coords
    
    box_info = {
        'min_coords': min_coords,
        'max_coords': max_coords,
        'mol_size': mol_size,
        'box_margin': box_margin
    }
    
    if use_resolution:
        nx, ny, nz = resolution
        actual_spacing = mol_size / np.array([nx, ny, nz])
        box_info['grid_spacing'] = actual_spacing
        box_info['total_points'] = nx * ny * nz
    else:
        # Calculate grid points from spacing and box size
        box_size = mol_size + 2 * box_margin
        nx = int(np.ceil(box_size[0] / grid_spacing))
        ny = int(np.ceil(box_size[1] / grid_spacing))
        nz = int(np.ceil(box_size[2] / grid_spacing))
        box_info['grid_spacing'] = [grid_spacing] * 3
        box_info['box_size'] = box_size
        box_info['total_points'] = nx * ny * nz
    
    return nx, ny, nz, box_info

# Calculate grid parameters
print("\n" + "="*70)
print("GRID PARAMETERS")
print("="*70)

if USE_GRID_RESOLUTION:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=True, resolution=GRID_RESOLUTION
    )
    print(f"Using fixed grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Molecule size: {box_info['mol_size']} Å")
    print(f"Effective grid spacing: {box_info['grid_spacing']} Å")
else:
    nx, ny, nz, box_info = calculate_grid_parameters(
        mol, use_resolution=False, box_margin=BOX_MARGIN, 
        grid_spacing=GRID_SPACING
    )
    print(f"Using box dimensions with margin: {BOX_MARGIN} Å")
    print(f"Grid spacing: {GRID_SPACING} Å")
    print(f"Calculated grid resolution: {nx} × {ny} × {nz}")
    print(f"Total grid points: {box_info['total_points']:,}")
    print(f"Box size: {box_info['box_size']} Å")

print("="*70)

# ============================================================================
# 8. GENERATE HOMO/LUMO CUBE FILES
# ============================================================================

if GENERATE_HOMO_LUMO:
    print("\n" + "="*70)
    print("GENERATING HOMO/LUMO CUBE FILES")
    print("="*70)
    
    # Get HOMO and LUMO indices (handle both RKS and UKS)
    if actual_spin == 1:  # RKS (closed-shell)
        mo_occ = mf.mo_occ
        mo_coeff = mf.mo_coeff
        mo_energy = mf.mo_energy
    else:  # UKS (open-shell) - use alpha orbitals
        mo_occ = mf.mo_occ[0]  # Alpha occupation
        mo_coeff = mf.mo_coeff[0]  # Alpha coefficients
        mo_energy = mf.mo_energy[0]  # Alpha energies
        print("Note: Using alpha orbitals for HOMO/LUMO (open-shell system)")
    
    # Convert CuPy to NumPy if needed
    if hasattr(mo_occ, 'get'):
        mo_occ = mo_occ.get()
        mo_coeff = mo_coeff.get()
        mo_energy = mo_energy.get()
    
    homo_idx = np.where(mo_occ > 0)[0][-1]
    lumo_idx = np.where(mo_occ == 0)[0][0]
    
    print(f"HOMO index: {homo_idx}")
    print(f"LUMO index: {lumo_idx}")
    print(f"HOMO energy: {mo_energy[homo_idx]*27.211:.3f} eV")
    print(f"LUMO energy: {mo_energy[lumo_idx]*27.211:.3f} eV")
    print(f"HOMO-LUMO gap: {(mo_energy[lumo_idx] - mo_energy[homo_idx])*27.211:.3f} eV")
    
    # Generate HOMO cube file
    homo_file = os.path.join(OUTPUT_DIR, 'HOMO.cube')
    cubegen.orbital(mol, homo_file, mo_coeff[:, homo_idx], nx=nx, ny=ny, nz=nz)
    print(f"\n  ✓ HOMO orbital: {homo_file}")
    
    # Generate LUMO cube file
    lumo_file = os.path.join(OUTPUT_DIR, 'LUMO.cube')
    cubegen.orbital(mol, lumo_file, mo_coeff[:, lumo_idx], nx=nx, ny=ny, nz=nz)
    print(f"  ✓ LUMO orbital: {lumo_file}")
    
    # Generate HOMO-1 and LUMO+1 for additional verification
    if homo_idx > 0:
        homo1_file = os.path.join(OUTPUT_DIR, 'HOMO-1.cube')
        cubegen.orbital(mol, homo1_file, mo_coeff[:, homo_idx-1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ HOMO-1 orbital: {homo1_file}")
    
    if lumo_idx < len(mo_occ) - 1:
        lumo1_file = os.path.join(OUTPUT_DIR, 'LUMO+1.cube')
        cubegen.orbital(mol, lumo1_file, mo_coeff[:, lumo_idx+1], nx=nx, ny=ny, nz=nz)
        print(f"  ✓ LUMO+1 orbital: {lumo1_file}")
    
    print("\nVerification tip:")
    print("For the first excited state (S1), check if the transition density")
    print("resembles a HOMO→LUMO transition by comparing:")
    print("  - transition_density_state1.cube")
    print("  - HOMO.cube (electron depletion)")
    print("  - LUMO.cube (electron accumulation)")
    
    # Analytical verification: Calculate HOMO→LUMO transition density
    print("\n" + "-"*70)
    print("ANALYTICAL VERIFICATION: HOMO→LUMO Transition Density")
    print("-"*70)
    
    # Construct approximate HOMO→LUMO transition density matrix
    homo_mo = mo_coeff[:, homo_idx]
    lumo_mo = mo_coeff[:, lumo_idx]
    
    # T_approx = |HOMO⟩⟨LUMO| + |LUMO⟩⟨HOMO|
    # In AO basis: T_μν = C_μ^HOMO * C_ν^LUMO + C_μ^LUMO * C_ν^HOMO
    t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
    
    # Generate cube file for HOMO→LUMO transition density
    homo_lumo_file = os.path.join(OUTPUT_DIR, 'transition_HOMO_LUMO_analytical.cube')
    cubegen.density(mol, homo_lumo_file, t_homo_lumo, nx=nx, ny=ny, nz=nz)
    print(f"  ✓ Analytical HOMO→LUMO transition: {homo_lumo_file}")
    
    print("\nTo verify S1 is a HOMO→LUMO transition, compare:")
    print(f"  1. {os.path.join(OUTPUT_DIR, 'transition_density_state1.cube')}")
    print(f"  2. {homo_lumo_file}")
    print("\nThey should be very similar if S1 is dominated by HOMO→LUMO excitation.")
    print("You can calculate the overlap/similarity in VMD or by visual inspection.")
    
    print("="*70)
else:
    print("\nHOMO/LUMO generation disabled.")

# ============================================================================
# 9. GENERATE CUBE FILES FOR SELECTED EXCITED STATES
# ============================================================================

print("\n" + "="*70)
print("GENERATING EXCITED STATE CUBE FILES")
print("="*70)

# Filter valid states
valid_states = [s for s in STATES_TO_OUTPUT if s < td.nstates]

if not valid_states:
    print("No valid states selected for cube file generation.")
else:
    print(f"Generating cube files for states: {[s+1 for s in valid_states]}")
    print(f"Grid resolution: {nx} × {ny} × {nz}")
    
    for state_id in valid_states:
        print(f"\nState {state_id+1}: {td.e[state_id]*27.211:.3f} eV")
        
        # 1. Transition density matrix
        if GENERATE_TRANSITION_DENSITY:
            dm_trans = calculate_transition_density_matrix(td, state_id)
            filename_trans = os.path.join(OUTPUT_DIR, f'transition_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_trans, dm_trans, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Transition density: {filename_trans}")
        
        # 2. Excited state density
        if GENERATE_EXCITED_DENSITY:
            dm_excited = calculate_excited_state_density(td, state_id)
            filename_excited = os.path.join(OUTPUT_DIR, f'excited_state_density_state{state_id+1}.cube')
            cubegen.density(mol, filename_excited, dm_excited, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Excited state density: {filename_excited}")
        
        # 3. Density difference
        if GENERATE_DENSITY_DIFFERENCE:
            if not GENERATE_EXCITED_DENSITY:
                dm_excited = calculate_excited_state_density(td, state_id)
            
            # Get ground state density and convert CuPy to NumPy if needed
            dm_ground = mf.make_rdm1()
            if hasattr(dm_ground, 'get'):
                dm_ground = dm_ground.get()
            
            # For UKS, dm_ground is a tuple (alpha, beta), sum them
            if isinstance(dm_ground, tuple):
                dm_ground = dm_ground[0] + dm_ground[1]
            
            dm_diff = dm_excited - dm_ground
            filename_diff = os.path.join(OUTPUT_DIR, f'density_difference_state{state_id+1}.cube')
            cubegen.density(mol, filename_diff, dm_diff, nx=nx, ny=ny, nz=nz)
            print(f"  ✓ Density difference: {filename_diff}")
        
        # Quantitative verification for first state
        if state_id == 0 and GENERATE_HOMO_LUMO and GENERATE_TRANSITION_DENSITY:
            print("\n  " + "-"*66)
            print("  QUANTITATIVE VERIFICATION: S1 vs HOMO→LUMO")
            print("  " + "-"*66)
            
            # Get HOMO and LUMO indices (handle both RKS and UKS)
            if actual_spin == 1:
                mo_occ_ver = mf.mo_occ
                mo_coeff_ver = mf.mo_coeff
            else:
                mo_occ_ver = mf.mo_occ[0]
                mo_coeff_ver = mf.mo_coeff[0]
            
            # Convert CuPy to NumPy if needed
            if hasattr(mo_occ_ver, 'get'):
                mo_occ_ver = mo_occ_ver.get()
                mo_coeff_ver = mo_coeff_ver.get()
            
            homo_idx = np.where(mo_occ_ver > 0)[0][-1]
            lumo_idx = np.where(mo_occ_ver == 0)[0][0]
            
            # Calculate analytical HOMO→LUMO transition density
            homo_mo = mo_coeff_ver[:, homo_idx]
            lumo_mo = mo_coeff_ver[:, lumo_idx]
            t_homo_lumo = np.outer(homo_mo, lumo_mo) + np.outer(lumo_mo, homo_mo)
            
            # Get TDDFT transition density for S1
            dm_trans_s1 = calculate_transition_density_matrix(td, 0)
            
            # Calculate overlap/similarity (Frobenius inner product)
            overlap = np.sum(dm_trans_s1 * t_homo_lumo)
            norm_tddft = np.linalg.norm(dm_trans_s1)
            norm_homo_lumo = np.linalg.norm(t_homo_lumo)
            similarity = overlap / (norm_tddft * norm_homo_lumo)
            
            # Calculate HOMO→LUMO contribution from TDDFT amplitudes
            X, Y = td.xy[0]
            
            # For UKS, X and Y are tuples (Xa, Xb), (Ya, Yb)
            if actual_spin > 1:
                Xa, Xb = X
                Ya, Yb = Y
                # Convert CuPy to NumPy if needed
                if hasattr(Xa, 'get'):
                    Xa = Xa.get()
                    Ya = Ya.get()
                # Use only alpha part for verification
                # HOMO is last occupied (nocc_a-1), LUMO is first virtual (0)
                homo_lumo_amplitude = abs(Xa[-1, 0] + Ya[-1, 0])
                total_amplitude = np.linalg.norm(Xa + Ya)
            else:
                # Convert CuPy to NumPy if needed
                if hasattr(X, 'get'):
                    X = X.get()
                    Y = Y.get()
                nocc = X.shape[0]
                nvir = X.shape[1]
                # HOMO is index nocc-1 in occupied space, LUMO is index 0 in virtual space
                homo_lumo_amplitude = abs(X[nocc-1, 0] + Y[nocc-1, 0])
                total_amplitude = np.linalg.norm(X + Y)
            
            homo_lumo_weight = (homo_lumo_amplitude / total_amplitude)**2
            
            print(f"  Similarity (cosine): {similarity:.4f}")
            print(f"  HOMO→LUMO weight: {homo_lumo_weight:.4f} ({homo_lumo_weight*100:.1f}%)")
            print(f"  HOMO→LUMO amplitude: {homo_lumo_amplitude:.4f}")
            
            if similarity > 0.95 and homo_lumo_weight > 0.8:
                print("  ✓ S1 is STRONGLY dominated by HOMO→LUMO transition")
            elif similarity > 0.85 and homo_lumo_weight > 0.6:
                print("  ✓ S1 is MOSTLY a HOMO→LUMO transition")
            elif similarity > 0.70 and homo_lumo_weight > 0.4:
                print("  ⚠ S1 has SIGNIFICANT HOMO→LUMO character but mixed")
            else:
                print("  ⚠ S1 is NOT a pure HOMO→LUMO transition (multi-configurational)")
            
            print("  " + "-"*66)

print("="*70)

# ============================================================================
# 9A. GENERATE ORBITAL PAIR TRANSITION DENSITY CUBE FILES
# ============================================================================

if ENABLE_CONTRIBUTION_ANALYSIS and GENERATE_PAIR_CUBES and 'all_contributions' in locals():
    print("\n" + "="*70)
    print("GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES")
    print("="*70)
    
    for state_id in valid_contrib_states:
        if state_id not in all_contributions:
            continue
        
        contributions, _ = all_contributions[state_id]
        excitation_energy = td.e[state_id] * 27.211
        
        print(f"\nState {state_id+1} ({excitation_energy:.4f} eV):")
        
        pair_count = 0
        for rank, (occ_idx, vir_idx, weight, label) in enumerate(contributions, 1):
            if pair_count >= MAX_PAIRS_PER_STATE:
                break
            
            if weight < PAIR_CONTRIBUTION_CUTOFF:
                print(f"  Skipping {label} (contribution {weight*100:.2f}% < {PAIR_CONTRIBUTION_CUTOFF*100:.0f}%)")
                continue
            
            # Calculate transition density for this pair
            t_dm_pair = calculate_pair_transition_density(mf, occ_idx, vir_idx)
            
            # Debug: Check dimensions
            nao = mol.nao_nr()
            if t_dm_pair.shape[0] != nao or t_dm_pair.shape[1] != nao:
                print(f"  ⚠ Warning: Density matrix shape {t_dm_pair.shape} doesn't match AO basis {nao}x{nao}")
                print(f"  Skipping {label} - dimension mismatch")
                continue
            
            # Generate cube file
            labels, _ = get_orbital_labels(mf)
            occ_label = labels[occ_idx].replace('-', 'm').replace('+', 'p')
            vir_label = labels[vir_idx].replace('-', 'm').replace('+', 'p')
            
            filename = os.path.join(OUTPUT_DIR, 
                f'transition_pair_state{state_id+1}_{occ_label}_to_{vir_label}.cube')
            
            try:
                cubegen.density(mol, filename, t_dm_pair, nx=nx, ny=ny, nz=nz)
                print(f"  ✓ Rank {rank}: {label} ({weight*100:.2f}%) → {filename}")
                pair_count += 1
            except (AssertionError, ValueError) as e:
                print(f"  ✗ Failed to generate cube for {label}: {str(e)}")
                continue
    
    print("="*70)

# ============================================================================
# 10. CALCULATION SUMMARY
# ============================================================================

print("\n" + "="*70)
print("CALCULATION SUMMARY")
print("="*70)

print(f"\nMolecule: {'XYZ file: ' + XYZ_FILE if USE_XYZ else 'H2O test molecule'}")
print(f"Basis set: {BASIS_SET}")
print(f"Number of atoms: {mol.natm}")
print(f"Number of electrons: {mol.nelectron}")
print(f"Number of basis functions: {mol.nao}")
print(f"Molecular charge: {mol.charge}")
print(f"Spin multiplicity: {actual_spin} ({'closed-shell' if actual_spin == 1 else 'open-shell'})")

print(f"\nComputational settings:")
print(f"  DFT method: {dft_method}")
print(f"  XC functional: {XC_FUNCTIONAL}")
print(f"  Parallel threads: {NUM_THREADS if NUM_THREADS > 0 else 'auto-detected'}")
print(f"  TDDFT method: Full TDDFT (not TDA)")
print(f"  Number of excited states calculated: {NUM_EXCITED_STATES}")

print(f"\nGrid settings:")
if USE_GRID_RESOLUTION:
    print(f"  Mode: Fixed resolution")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")
else:
    print(f"  Mode: Box dimensions")
    print(f"  Margin: {BOX_MARGIN} Å, Spacing: {GRID_SPACING} Å")
    print(f"  Grid: {nx} × {ny} × {nz} = {nx*ny*nz:,} points")

print(f"\nOutput files generated:")
if GENERATE_HOMO_LUMO:
    print(f"  ✓ HOMO/LUMO orbitals (in {OUTPUT_DIR}/)")
if ENABLE_NTO_ANALYSIS and valid_nto_states:
    print(f"  ✓ NTO analysis for {len(valid_nto_states)} state(s)")
if valid_states:
    print(f"  ✓ Cube files for {len(valid_states)} state(s):")
    if GENERATE_TRANSITION_DENSITY:
        print(f"    - Transition density matrices")
    if GENERATE_EXCITED_DENSITY:
        print(f"    - Excited state densities")
    if GENERATE_DENSITY_DIFFERENCE:
        print(f"    - Density differences")

print(f"\nAll output files saved to: {OUTPUT_DIR}/")

print("\n" + "="*70)
print("VISUALIZATION GUIDE")
print("="*70)
print("""
Three types of cube files generated:

1. transition_density_state*.cube
   - Represents the electronic transition between ground and excited state
   - Used for calculating transition dipole moments
   - Visualize with isovalues ±0.002

2. excited_state_density_state*.cube
   - Total electron density in the excited state
   - Compare with ground state density

3. density_difference_state*.cube
   - Change in electron density (excited - ground)
   - Red/positive: electron accumulation
   - Blue/negative: electron depletion
   - Recommended for visualization

VMD visualization:
  vmd output/density_difference_state1.cube
  Graphics > Representations > Drawing Method: Isosurface
  - Rep 1: Isovalue = +0.002, Color = Red (electron gain)
  - Rep 2: Isovalue = -0.002, Color = Blue (electron loss)

Jmol visualization:
  isosurface ID "surf1" cutoff  0.002 output/density_difference_state1.cube
  isosurface ID "surf2" cutoff -0.002 output/density_difference_state1.cube

HOMO/LUMO verification:
  Compare transition_density_state1.cube with HOMO.cube and LUMO.cube
  to verify that S1 corresponds to a HOMO→LUMO transition.

NTO visualization:
  Open output/nto_state_*.molden files in Jmol, Avogadro, or VMD
""")
print("="*70)

print("\n✓ Calculation completed successfully!")
print(f"✓ All files saved to: {OUTPUT_DIR}/\n")
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='DesktopGTX3060', release='5.15.0-161-generic', version='#171-Ubuntu SMP Sat Oct 11 08:17:01 UTC 2025', machine='x86_64')  Threads 12
Python 3.10.12 (main, Aug 15 2025, 14:32:43) [GCC 11.4.0]
numpy 1.26.4  scipy 1.11.4  h5py 3.15.1
Date: Tue Nov 18 17:17:29 2025
PySCF version 2.11.0
PySCF path  /home/indranil/.local/lib/python3.10/site-packages/pyscf/__init__.py
CUDA Environment
    CuPy 13.4.1
    CUDA Path /usr
    CUDA Build Version 12080
    CUDA Driver Version 12090
    CUDA Runtime Version 12080
CUDA toolkit
    cuSolver (11, 7, 4)
    cuBLAS 120900
    cuTENSOR 20301
Device info
    Device name b'NVIDIA GeForce RTX 3060'
    Device global memory 11.63 GB
    CuPy memory fraction 0.9
    Num. Devices 1
GPU4PySCF 1.4.3
GPU4PySCF path  /home/indranil/.local/lib/python3.10/site-packages/gpu4pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 38
[INPUT] num. electrons = 201
[INPUT] charge = -1
[INPUT] spin (= nelec alpha-beta = 2S) = 1
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 C      2.896522000000   0.014575000000   0.000000000000 AA    5.473633293777   0.027542758266   0.000000000000 Bohr   0.0
[INPUT]  2 C     -3.625534000000  -1.241935000000   0.000000000000 AA   -6.851266315299  -2.346917014512   0.000000000000 Bohr   0.0
[INPUT]  3 C      1.437634000000   0.009164000000   0.000000000000 AA    2.716734527363   0.017317450206   0.000000000000 Bohr   0.0
[INPUT]  4 C     -2.895730000000  -0.014912000000   0.000000000000 AA   -5.472136630687  -0.028179595970   0.000000000000 Bohr   0.0
[INPUT]  5 C      0.729281000000  -1.249862000000   0.000000000000 AA    1.378141357849  -2.361896873501   0.000000000000 Bohr   0.0
[INPUT]  6 C     -0.727755000000  -1.261619000000   0.000000000000 AA   -1.375257635783  -2.384114383548   0.000000000000 Bohr   0.0
[INPUT]  7 C     -1.436957000000  -0.009874000000   0.000000000000 AA   -2.715455182777  -0.018659155754   0.000000000000 Bohr   0.0
[INPUT]  8 C      3.626674000000   1.242670000000   0.000000000000 AA    6.853420603081   2.348305963213   0.000000000000 Bohr   0.0
[INPUT]  9 C      0.728503000000   1.260811000000   0.000000000000 AA    1.376671150924   2.382587484839   0.000000000000 Bohr   0.0
[INPUT] 10 C     -5.092425000000  -1.228040000000   0.000000000000 AA   -9.623288559888  -2.320659270011   0.000000000000 Bohr   0.0
[INPUT] 11 C     -0.728118000000   1.249065000000   0.000000000000 AA   -1.375943606366   2.360390761780   0.000000000000 Bohr   0.0
[INPUT] 12 C     -5.057623000000   1.241537000000   0.000000000000 AA   -9.557522311301   2.346164903514   0.000000000000 Bohr   0.0
[INPUT] 13 C     -2.901906000000  -2.476606000000   0.000000000000 AA   -5.483807579232  -4.680107058455   0.000000000000 Bohr   0.0
[INPUT] 14 C      3.601221000000  -1.226169000000   0.000000000000 AA    6.805321404032  -2.317123592432   0.000000000000 Bohr   0.0
[INPUT] 15 C      1.487021000000  -2.470749000000   0.000000000000 AA    2.810062431477  -4.669038932543   0.000000000000 Bohr   0.0
[INPUT] 16 C      2.901581000000   2.477708000000   0.000000000000 AA    5.483193418242   4.682189536644   0.000000000000 Bohr   0.0
[INPUT] 17 C      5.092590000000   1.230486000000   0.000000000000 AA    9.623600364699   2.325281540112   0.000000000000 Bohr   0.0
[INPUT] 18 C     -1.492998000000  -2.485108000000   0.000000000000 AA   -2.821357324523  -4.696173509966   0.000000000000 Bohr   0.0
[INPUT] 19 C      5.056187000000  -1.242165000000   0.000000000000 AA    9.554808664586  -2.347351651520   0.000000000000 Bohr   0.0
[INPUT] 20 C      1.493062000000   2.485432000000   0.000000000000 AA    2.821478266995   4.696785781230   0.000000000000 Bohr   0.0
[INPUT] 21 C     -3.601702000000   1.225997000000   0.000000000000 AA   -6.806230362298   2.316798559538   0.000000000000 Bohr   0.0
[INPUT] 22 C      2.893134000000  -2.460012000000   0.000000000000 AA    5.467230901667  -4.648748943144   0.000000000000 Bohr   0.0
[INPUT] 23 C     -1.485604000000   2.469918000000   0.000000000000 AA   -2.807384689558   4.667468570133   0.000000000000 Bohr   0.0
[INPUT] 24 C     -2.893236000000   2.458717000000   0.000000000000 AA   -5.467423653732   4.646301747812   0.000000000000 Bohr   0.0
[INPUT] 25 O     -5.732320000000   0.026109000000   0.000000000000 AA  -10.832514858367   0.049338859386   0.000000000000 Bohr   0.0
[INPUT] 26 O      5.734140000000  -0.025581000000   0.000000000000 AA   10.835954159914  -0.048341083992   0.000000000000 Bohr   0.0
[INPUT] 27 O     -5.767539000000   2.259992000000   0.000000000000 AA  -10.899069122748   4.270765923708   0.000000000000 Bohr   0.0
[INPUT] 28 O     -5.856852000000  -2.197455000000   0.000000000000 AA  -11.067846232111  -4.152588121056   0.000000000000 Bohr   0.0
[INPUT] 29 O      5.766769000000  -2.260350000000   0.000000000000 AA   10.897614033632  -4.271442445661   0.000000000000 Bohr   0.0
[INPUT] 30 O      5.853157000000   2.198203000000   0.000000000000 AA   11.060863694081   4.154001636197   0.000000000000 Bohr   0.0
[INPUT] 31 H      0.966973000000  -3.439928000000   0.000000000000 AA    1.827314139849  -6.500521808223   0.000000000000 Bohr   0.0
[INPUT] 32 H     -3.465927000000  -3.425329000000   0.000000000000 AA   -6.549652797735  -6.472933696530   0.000000000000 Bohr   0.0
[INPUT] 33 H     -0.969686000000  -3.454698000000   0.000000000000 AA   -1.832440966825  -6.528433063083   0.000000000000 Bohr   0.0
[INPUT] 34 H      0.969067000000   3.454476000000   0.000000000000 AA    1.831271226354   6.528013543883   0.000000000000 Bohr   0.0
[INPUT] 35 H      3.465022000000   3.426681000000   0.000000000000 AA    6.547942595593   6.475488606251   0.000000000000 Bohr   0.0
[INPUT] 36 H      3.481146000000  -3.397659000000   0.000000000000 AA    6.578412539625  -6.420644974664   0.000000000000 Bohr   0.0
[INPUT] 37 H     -0.966845000000   3.439743000000   0.000000000000 AA   -1.827072254905   6.500172208890   0.000000000000 Bohr   0.0
[INPUT] 38 H     -3.480925000000   3.396767000000   0.000000000000 AA   -6.577994910152   6.418959338960   0.000000000000 Bohr   0.0

nuclear repulsion = 2584.1133492772
number of shells = 166
number of NR pGTOs = 692
number of NR cGTOs = 286
basis = 6-31g
ecp = {}
CPU time:         2.44
Number of atoms: 38
Number of electrons: 201
Number of basis functions: 286
Molecular charge: -1
Spin multiplicity (2S+1): 2
Number of unpaired electrons (2S): 1
System type: Open-shell (doublet)
DFT method: UKS (GPU-accelerated)

======================================================================
GROUND STATE DFT CALCULATION
======================================================================
XC functional: b3lyp
Basis set: 6-31g
Method: UKS (GPU-accelerated)
XC library gpu4pyscf.dft.libxc version 7.0.0 (CUDA)
    unable to decode the reference due to https://github.com/NVIDIA/cuda-python/issues/29
XC functionals = b3lyp
radial grids: 
    Treutler-Ahlrichs [JCP 102, 346 (1995); DOI:10.1063/1.469408] (M4) radial grids
    
becke partition: Becke, JCP 88, 2547 (1988); DOI:10.1063/1.454033
pruning grids: <function nwchem_prune at 0x7faea4f416c0>
grids dens level: 3
symmetrized grids: False
atomic radii adjust function: <function treutler_atomic_radii_adjust at 0x7faea4f41510>
small_rho_cutoff = 1e-07
Set gradient conv threshold to 3.16228e-05
tot grids = 502016
init E= -1376.38324328275
  alpha nocc = 101  HOMO = -0.186194043847459  LUMO = -0.123639885211096
  beta  nocc = 100  HOMO = -0.24153753665407  LUMO = -0.186194043847459

WARN: system HOMO -0.186194043847459 >= system LUMO -0.186194043847459

cycle= 1 E= -1369.77930536392  delta_E=  6.6  |g|= 1.31  |ddm|= 5.68

WARN: alpha nocc = 101  HOMO 0.0165046360827251 >= LUMO 0.0173099561331184


WARN: beta  nocc = 100  HOMO 0.0170934233276519 >= LUMO 0.0178838311200048

cycle= 2 E= -1364.26715776941  delta_E= 5.51  |g|= 3.53  |ddm|= 6.69
  alpha nocc = 101  HOMO = -0.0322931788904281  LUMO = 0.0459652867279221
  beta  nocc = 100  HOMO = -0.0731473362517626  LUMO = -0.00634964377952459
cycle= 3 E= -1370.2671476534  delta_E=   -6  |g|= 0.675  |ddm|= 5.77
  alpha nocc = 101  HOMO = -0.0633310470805632  LUMO = 0.0149495100615959
  beta  nocc = 100  HOMO = -0.109684344513127  LUMO = -0.0354674918382411
cycle= 4 E= -1370.50057853684  delta_E= -0.233  |g|= 0.206  |ddm|= 1.08
  alpha nocc = 101  HOMO = -0.0717909949796935  LUMO = 0.0152726356344571
  beta  nocc = 100  HOMO = -0.117432554251143  LUMO = -0.0381784826148723
cycle= 5 E= -1370.5092824274  delta_E= -0.0087  |g|= 0.15  |ddm|= 0.454
  alpha nocc = 101  HOMO = -0.069751593077919  LUMO = 0.0173626976864717
  beta  nocc = 100  HOMO = -0.113692602237938  LUMO = -0.0345747747599557
cycle= 6 E= -1370.52177499673  delta_E= -0.0125  |g|= 0.0378  |ddm|= 0.249
  alpha nocc = 101  HOMO = -0.06661307308873  LUMO = 0.0209346687817906
  beta  nocc = 100  HOMO = -0.110052482322235  LUMO = -0.0306629500917387
cycle= 7 E= -1370.52261664283  delta_E= -0.000842  |g|= 0.0147  |ddm|= 0.066
  alpha nocc = 101  HOMO = -0.067029859625774  LUMO = 0.0210973762910137
  beta  nocc = 100  HOMO = -0.110220400485482  LUMO = -0.0306111822004647
cycle= 8 E= -1370.52271295835  delta_E= -9.63e-05  |g|= 0.00578  |ddm|= 0.022
  alpha nocc = 101  HOMO = -0.0671092879241968  LUMO = 0.0212305793964718
  beta  nocc = 100  HOMO = -0.109885528019303  LUMO = -0.0303617593077989
cycle= 9 E= -1370.52274403082  delta_E= -3.11e-05  |g|= 0.00224  |ddm|= 0.0136
  alpha nocc = 101  HOMO = -0.0672611264887226  LUMO = 0.021220406501801
  beta  nocc = 100  HOMO = -0.109733336025476  LUMO = -0.0302667664758707
cycle= 10 E= -1370.52275190674  delta_E= -7.88e-06  |g|= 0.00186  |ddm|= 0.00732
  alpha nocc = 101  HOMO = -0.0672527139895976  LUMO = 0.0212982251090216
  beta  nocc = 100  HOMO = -0.109615994843002  LUMO = -0.0301852171533624
cycle= 11 E= -1370.52275491523  delta_E= -3.01e-06  |g|= 0.000826  |ddm|= 0.00368
  alpha nocc = 101  HOMO = -0.0672982912767181  LUMO = 0.0213106747307692
  beta  nocc = 100  HOMO = -0.109552304103485  LUMO = -0.0301657980865001
cycle= 12 E= -1370.52275601772  delta_E= -1.1e-06  |g|= 0.000767  |ddm|= 0.00289
  alpha nocc = 101  HOMO = -0.0673361568237503  LUMO = 0.0212893960451659
  beta  nocc = 100  HOMO = -0.109529400619647  LUMO = -0.0301622218282441
cycle= 13 E= -1370.52275644637  delta_E= -4.29e-07  |g|= 0.000362  |ddm|= 0.00186
  alpha nocc = 101  HOMO = -0.0673226017624988  LUMO = 0.0213201034918958
  beta  nocc = 100  HOMO = -0.109491318260718  LUMO = -0.0301367617715929
cycle= 14 E= -1370.5227565408  delta_E= -9.44e-08  |g|= 9.87e-05  |ddm|= 0.000821
  alpha nocc = 101  HOMO = -0.0673201901289359  LUMO = 0.0213168050349618
  beta  nocc = 100  HOMO = -0.109491010285572  LUMO = -0.0301397002994899
cycle= 15 E= -1370.5227565496  delta_E= -8.8e-09  |g|= 8.54e-05  |ddm|= 0.000291
  alpha nocc = 101  HOMO = -0.0673205848134753  LUMO = 0.0213172412156126
  beta  nocc = 100  HOMO = -0.109491431859734  LUMO = -0.0301408159337735
cycle= 16 E= -1370.52275655394  delta_E= -4.34e-09  |g|= 5.4e-05  |ddm|= 0.00018
  alpha nocc = 101  HOMO = -0.0673228240244951  LUMO = 0.021317480941948
  beta  nocc = 100  HOMO = -0.109492788750346  LUMO = -0.0301424811075551
cycle= 17 E= -1370.5227565549  delta_E= -9.64e-10  |g|= 4.34e-05  |ddm|= 0.000126
  alpha nocc = 101  HOMO = -0.0673211165870319  LUMO = 0.0213181961970072
  beta  nocc = 100  HOMO = -0.109490496308888  LUMO = -0.0301412084971614
cycle= 18 E= -1370.52275655605  delta_E= -1.15e-09  |g|= 2.02e-05  |ddm|= 9.18e-05
  alpha nocc = 101  HOMO = -0.0673210568849192  LUMO = 0.0213175598903746
  beta  nocc = 100  HOMO = -0.109491511441684  LUMO = -0.0301420575636931
cycle= 19 E= -1370.52275655643  delta_E= -3.82e-10  |g|= 8.6e-06  |ddm|= 4.27e-05
converged SCF energy = -1370.52275655643  <S^2> = 0.76080024  2S+1 = 2.0107712
✓ SCF converged
Ground state energy: -1370.522757 a.u.

======================================================================
TDDFT CALCULATION
======================================================================
Note: TDDFT inherits XC functional (b3lyp) and basis set (6-31g) from ground state
TDDFT method: TDDFT (UKS-based, GPU-accelerated)
Using full TDDFT - more accurate but slower
Calculating 10 excited states...


******** <class 'gpu4pyscf.tdscf.uks.TDDFT'> for <class 'gpu4pyscf.dft.uks.UKS'> ********
nstates = 10
deg_eia_thresh = 1.000e-03
wfnsym = None
conv_tol = 1e-05
eigh lindep = 1e-12
eigh level_shift = 0
eigh max_cycle = 100
chkfile = None
max_memory 4000 MB (current use 1436 MB)


Excited State energies (eV)
[1.44509478 1.78757391 2.13573097 2.43106876 2.55806349 2.7483043
 2.91413288 2.99311386 2.99757242 3.0107168 ]
✓ TDDFT converged (all states)

** Excitation energies and oscillator strengths **
Excited State   1:      1.44509 eV    857.97 nm  f=0.0266
     101a ->  102a      0.31200
     101a ->  103a      0.40055
     100b ->  101b     -0.85654
Excited State   2:      1.78757 eV    693.59 nm  f=0.0393
     101a ->  102a     -0.82187
     101a ->  103a      0.54027
      94b ->  101b     -0.10136
Excited State   3:      2.13573 eV    580.52 nm  f=0.6750
     101a ->  102a      0.44495
     101a ->  103a      0.72028
     100b ->  101b      0.48134
Excited State   4:      2.43107 eV    510.00 nm  f=0.0010
     101a ->  104a     -0.98149
Excited State   5:      2.55806 eV    484.68 nm  f=0.0000
     100a ->  102a      0.38871
     100a ->  103a     -0.26061
     101a ->  105a      0.50335
     101a ->  106a     -0.23027
      95b ->  101b      0.39204
      97b ->  101b      0.13166
     100b ->  102b     -0.47794
     100b ->  103b      0.16546
Excited State   6:      2.74830 eV    451.13 nm  f=0.0000
     100a ->  102a     -0.30399
     100a ->  103a     -0.42823
     101a ->  107a      0.30426
      96b ->  101b     -0.37520
      97b ->  101b      0.39543
     100b ->  102b      0.20705
     100b ->  103b      0.49899
Excited State   7:      2.91413 eV    425.46 nm  f=0.0000
     100a ->  103a      0.11094
     100a ->  104a      0.16718
     101a ->  106a     -0.91564
      97b ->  101b     -0.12647
     100b ->  102b      0.19249
Excited State   8:      2.99311 eV    414.23 nm  f=0.0001
      98b ->  101b      0.16437
      98b ->  103b     -0.21450
      99b ->  101b      0.93834
Excited State   9:      2.99757 eV    413.62 nm  f=0.0000
      98b ->  101b      0.93789
      99b ->  101b     -0.16488
      99b ->  103b     -0.21578
Excited State  10:      3.01072 eV    411.81 nm  f=0.0000
     100a ->  102a     -0.18181
     101a ->  105a      0.63512
      95b ->  101b     -0.12245
      96b ->  101b     -0.43088
      97b ->  101b     -0.54424
     100b ->  102b      0.14319

** Transition electric dipole moments (AU) **
state          X           Y           Z        Dip. S.      Osc.
  1        -0.8658      0.0237     -0.0000      0.7502      0.0266
  2        -0.2118     -0.9233     -0.0000      0.8973      0.0393
  3         3.5914     -0.0375      0.0000     12.8996      0.6750
  4        -0.1089     -0.0729     -0.0000      0.0172      0.0010
  5         0.0087      0.0011      0.0000      0.0001      0.0000
  6        -0.0120     -0.0008     -0.0000      0.0001      0.0000
  7        -0.0003      0.0003      0.0000      0.0000      0.0000
  8         0.0000     -0.0000      0.0345      0.0012      0.0001
  9         0.0000     -0.0000     -0.0029      0.0000      0.0000
 10         0.0022      0.0009      0.0000      0.0000      0.0000

** Transition velocity dipole moments (imaginary part, AU) **
state          X           Y           Z        Dip. S.      Osc.
  1        -0.0426      0.0015     -0.0000      0.0018      0.0228
  2        -0.0124     -0.0666     -0.0000      0.0046      0.0466
  3         0.2464     -0.0032      0.0000      0.0607      0.5158
  4        -0.0084     -0.0090     -0.0000      0.0002      0.0011
  5         0.0007      0.0001      0.0000      0.0000      0.0000
  6        -0.0011     -0.0001     -0.0000      0.0000      0.0000
  7        -0.0000      0.0000     -0.0000      0.0000      0.0000
  8         0.0000     -0.0000      0.0048      0.0000      0.0001
  9         0.0000     -0.0000     -0.0004      0.0000      0.0000
 10         0.0002      0.0001      0.0000      0.0000      0.0000

** Transition magnetic dipole moments (imaginary part, AU) **
state          X           Y           Z
  1         0.0000      0.0000      0.0000
  2        -0.0000      0.0000      0.0001
  3        -0.0000     -0.0000     -0.0000
  4         0.0000      0.0000     -0.0068
  5         0.0000     -0.0000     -0.7557
  6        -0.0000     -0.0000     -0.1181
  7        -0.0000      0.0000     -1.2615
  8         0.0025      0.0287     -0.0000
  9        -0.0053      0.3256     -0.0000
 10        -0.0000      0.0000      0.6803

======================================================================
EXCITED STATE ENERGIES
======================================================================
State 1: 0.053106 a.u. = 1.445 eV
State 2: 0.065692 a.u. = 1.788 eV
State 3: 0.078487 a.u. = 2.136 eV
State 4: 0.089340 a.u. = 2.431 eV
State 5: 0.094007 a.u. = 2.558 eV
State 6: 0.100998 a.u. = 2.748 eV
State 7: 0.107092 a.u. = 2.914 eV
State 8: 0.109995 a.u. = 2.993 eV
State 9: 0.110159 a.u. = 2.998 eV
State 10: 0.110642 a.u. = 3.011 eV
======================================================================

======================================================================
TRANSITION DIPOLE MOMENTS
======================================================================

Transition dipole moments (a.u.):
State    μ_x          μ_y          μ_z          |μ|          f           
----------------------------------------------------------------------
1          -0.865789    0.023731   -0.000000    0.866114    0.026559
2          -0.211824   -0.923266   -0.000000    0.947254    0.039297
3           3.591412   -0.037478    0.000000    3.591607    0.674967
4          -0.108918   -0.072885   -0.000000    0.131055    0.001023
5           0.008663    0.001135    0.000000    0.008737    0.000005
6          -0.011963   -0.000840   -0.000000    0.011992    0.000010
7          -0.000253    0.000277    0.000000    0.000375    0.000000
8           0.000000   -0.000000    0.034451    0.034451    0.000087
9           0.000000   -0.000000   -0.002865    0.002865    0.000001
10          0.002187    0.000930    0.000000    0.002377    0.000000
======================================================================

======================================================================
NATURAL TRANSITION ORBITAL ANALYSIS
======================================================================

State 1 (1.445 eV):
State 1: 1.44509 eV  NTO largest component 0.9739103852353435
    alpha occ-NTO: 0.997596 (MO #101)
    alpha vir-NTO: 0.614670 (MO #102) + 0.787780 (MO #103)
    beta occ-NTO: 0.999992 (MO #100)
    beta vir-NTO: 0.999913 (MO #101)
  Alpha NTO orbitals saved to: output_gpu_charge-1/nto_state_1_alpha.molden
  Beta NTO orbitals saved to: output_gpu_charge-1/nto_state_1_beta.molden

State 2 (1.788 eV):
State 2: 1.78757 eV  NTO largest component 0.9720317081437385
    alpha occ-NTO: 0.999951 (MO #101)
    alpha vir-NTO: 0.835152 (MO #102) + -0.549348 (MO #103)
    beta occ-NTO: 0.412646 (MO #91) + 0.712096 (MO #94) + 0.553031 (MO #100)
    beta vir-NTO: 0.926289 (MO #101) + -0.349023 (MO #105)
  Alpha NTO orbitals saved to: output_gpu_charge-1/nto_state_2_alpha.molden
  Beta NTO orbitals saved to: output_gpu_charge-1/nto_state_2_beta.molden

State 3 (2.136 eV):
State 3: 2.13573 eV  NTO largest component 0.9028556997366463
    alpha occ-NTO: 0.998716 (MO #101)
    alpha vir-NTO: 0.524379 (MO #102) + 0.851076 (MO #103)
    beta occ-NTO: 0.999052 (MO #100)
    beta vir-NTO: 0.991935 (MO #101)
  Alpha NTO orbitals saved to: output_gpu_charge-1/nto_state_3_alpha.molden
  Beta NTO orbitals saved to: output_gpu_charge-1/nto_state_3_beta.molden
======================================================================

======================================================================
TRANSITION CONTRIBUTION ANALYSIS
======================================================================
Analyzing orbital pair contributions to excited states...

======================================================================
STATE 1: 1.4451 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
1      LUMO+98 → LUMO+100   0.627845     62.78       % 62.78       %
2      LUMO+98 → LUMO+99    0.372155     37.22       % 100.00      %
----------------------------------------------------------------------
Total weight analyzed: 0.312827

======================================================================
STATE 2: 1.7875 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
1      LUMO+98 → LUMO+99    0.693542     69.35       % 69.35       %
2      LUMO+98 → LUMO+100   0.306458     30.65       % 100.00      %
----------------------------------------------------------------------
Total weight analyzed: 0.934607

======================================================================
STATE 3: 2.1357 eV
======================================================================
Rank   Transition           Weight       Percentage   Cumulative  
----------------------------------------------------------------------
1      LUMO+98 → LUMO+100   0.691824     69.18       % 69.18       %
2      LUMO+98 → LUMO+99    0.257961     25.80       % 94.98       %
3      LUMO+91 → LUMO+99    0.031237     3.12        % 98.10       %
4      LUMO+94 → LUMO+99    0.018978     1.90        % 100.00      %
----------------------------------------------------------------------
Total weight analyzed: 0.600947

✓ Contribution tables saved to: output_gpu_charge-1/contribution_tables.txt

======================================================================
GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES
======================================================================
Note: Cube files will be generated after grid parameters are calculated
      (see CUBE FILE GENERATION section below)
======================================================================

======================================================================
GRID PARAMETERS
======================================================================
Using box dimensions with margin: 4.0 Å
Grid spacing: 0.2 Å
Calculated grid resolution: 99 × 75 × 40
Total grid points: 297,000
Box size: [19.71000433 14.90917125  8.        ] Å
======================================================================

======================================================================
GENERATING HOMO/LUMO CUBE FILES
======================================================================
Note: Using alpha orbitals for HOMO/LUMO (open-shell system)
HOMO index: 100
LUMO index: 101
HOMO energy: -1.832 eV
LUMO energy: 0.580 eV
HOMO-LUMO gap: 2.412 eV

  ✓ HOMO orbital: output_gpu_charge-1/HOMO.cube
  ✓ LUMO orbital: output_gpu_charge-1/LUMO.cube
  ✓ HOMO-1 orbital: output_gpu_charge-1/HOMO-1.cube
  ✓ LUMO+1 orbital: output_gpu_charge-1/LUMO+1.cube

Verification tip:
For the first excited state (S1), check if the transition density
resembles a HOMO→LUMO transition by comparing:
  - transition_density_state1.cube
  - HOMO.cube (electron depletion)
  - LUMO.cube (electron accumulation)

----------------------------------------------------------------------
ANALYTICAL VERIFICATION: HOMO→LUMO Transition Density
----------------------------------------------------------------------
  ✓ Analytical HOMO→LUMO transition: output_gpu_charge-1/transition_HOMO_LUMO_analytical.cube

To verify S1 is a HOMO→LUMO transition, compare:
  1. output_gpu_charge-1/transition_density_state1.cube
  2. output_gpu_charge-1/transition_HOMO_LUMO_analytical.cube

They should be very similar if S1 is dominated by HOMO→LUMO excitation.
You can calculate the overlap/similarity in VMD or by visual inspection.
======================================================================

======================================================================
GENERATING EXCITED STATE CUBE FILES
======================================================================
Generating cube files for states: [1, 2, 3]
Grid resolution: 99 × 75 × 40

State 1: 1.445 eV
  ✓ Transition density: output_gpu_charge-1/transition_density_state1.cube
  ✓ Excited state density: output_gpu_charge-1/excited_state_density_state1.cube
  ✓ Density difference: output_gpu_charge-1/density_difference_state1.cube

  ------------------------------------------------------------------
  QUANTITATIVE VERIFICATION: S1 vs HOMO→LUMO
  ------------------------------------------------------------------
  Similarity (cosine): 0.3621
  HOMO→LUMO weight: 0.3413 (34.1%)
  HOMO→LUMO amplitude: 0.3412
  ⚠ S1 is NOT a pure HOMO→LUMO transition (multi-configurational)
  ------------------------------------------------------------------

State 2: 1.788 eV
  ✓ Transition density: output_gpu_charge-1/transition_density_state2.cube
  ✓ Excited state density: output_gpu_charge-1/excited_state_density_state2.cube
  ✓ Density difference: output_gpu_charge-1/density_difference_state2.cube

State 3: 2.136 eV
  ✓ Transition density: output_gpu_charge-1/transition_density_state3.cube
  ✓ Excited state density: output_gpu_charge-1/excited_state_density_state3.cube
  ✓ Density difference: output_gpu_charge-1/density_difference_state3.cube
======================================================================

======================================================================
GENERATING ORBITAL PAIR TRANSITION DENSITY CUBE FILES
======================================================================

State 1 (1.4451 eV):
  ⚠ Warning: Density matrix shape (572, 572) doesn't match AO basis 286x286
  Skipping LUMO+98 → LUMO+100 - dimension mismatch
  ⚠ Warning: Density matrix shape (572, 572) doesn't match AO basis 286x286
  Skipping LUMO+98 → LUMO+99 - dimension mismatch

State 2 (1.7875 eV):
  ⚠ Warning: Density matrix shape (572, 572) doesn't match AO basis 286x286
  Skipping LUMO+98 → LUMO+99 - dimension mismatch
  ⚠ Warning: Density matrix shape (572, 572) doesn't match AO basis 286x286
  Skipping LUMO+98 → LUMO+100 - dimension mismatch

State 3 (2.1357 eV):
  ⚠ Warning: Density matrix shape (572, 572) doesn't match AO basis 286x286
  Skipping LUMO+98 → LUMO+100 - dimension mismatch
  ⚠ Warning: Density matrix shape (572, 572) doesn't match AO basis 286x286
  Skipping LUMO+98 → LUMO+99 - dimension mismatch
  Skipping LUMO+91 → LUMO+99 (contribution 3.12% < 5%)
  Skipping LUMO+94 → LUMO+99 (contribution 1.90% < 5%)
======================================================================

======================================================================
CALCULATION SUMMARY
======================================================================

Molecule: XYZ file: PTCDA_clean.xyz
Basis set: 6-31g
Number of atoms: 38
Number of electrons: 201
Number of basis functions: 286
Molecular charge: -1
Spin multiplicity: 2 (open-shell)

Computational settings:
  DFT method: UKS
  XC functional: b3lyp
  Parallel threads: auto-detected
  TDDFT method: Full TDDFT (not TDA)
  Number of excited states calculated: 10

Grid settings:
  Mode: Box dimensions
  Margin: 4.0 Å, Spacing: 0.2 Å
  Grid: 99 × 75 × 40 = 297,000 points

Output files generated:
  ✓ HOMO/LUMO orbitals (in output_gpu_charge-1/)
  ✓ NTO analysis for 3 state(s)
  ✓ Cube files for 3 state(s):
    - Transition density matrices
    - Excited state densities
    - Density differences

All output files saved to: output_gpu_charge-1/

======================================================================
VISUALIZATION GUIDE
======================================================================

Three types of cube files generated:

1. transition_density_state*.cube
   - Represents the electronic transition between ground and excited state
   - Used for calculating transition dipole moments
   - Visualize with isovalues ±0.002

2. excited_state_density_state*.cube
   - Total electron density in the excited state
   - Compare with ground state density

3. density_difference_state*.cube
   - Change in electron density (excited - ground)
   - Red/positive: electron accumulation
   - Blue/negative: electron depletion
   - Recommended for visualization

VMD visualization:
  vmd output/density_difference_state1.cube
  Graphics > Representations > Drawing Method: Isosurface
  - Rep 1: Isovalue = +0.002, Color = Red (electron gain)
  - Rep 2: Isovalue = -0.002, Color = Blue (electron loss)

Jmol visualization:
  isosurface ID "surf1" cutoff  0.002 output/density_difference_state1.cube
  isosurface ID "surf2" cutoff -0.002 output/density_difference_state1.cube

HOMO/LUMO verification:
  Compare transition_density_state1.cube with HOMO.cube and LUMO.cube
  to verify that S1 corresponds to a HOMO→LUMO transition.

NTO visualization:
  Open output/nto_state_*.molden files in Jmol, Avogadro, or VMD

======================================================================

✓ Calculation completed successfully!
✓ All files saved to: output_gpu_charge-1/

